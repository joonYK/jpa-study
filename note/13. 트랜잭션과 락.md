# 트랜잭션과 격리 수준

## 트랜잭션의 ACID 보장

### 원자성(Atomicity)
* 트랜잭션 내에서 실행한 작업들은 하나의 작업인 것처럼 모두 성공하든가 모두 실패.

### 일관성(Consistency)
* 모든 트랜잭션은 일관성 있는 DB 상태 유지.
  * 예를 들어 DB 에서 정한 무결성 제약 조건을 항상 만족해야 함.

### 격리성(Isolation)
* 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않도록 격리.
  * 예를 들어 동시에 같은 데이터를 수정 못함.
* 동시성과 관련된 성능 이슈로 인해 격리 수준 선택.
 
### 지속성(Durability)
* 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 함.
* 중간에 시스템에 문제가 생겨도 DB 로그 등으로 성공한 트랜잭션 내용 복구.

## 트랜잭션 격리 수준

* 트랜잭션 간에 격리성을 완벽히 보장하려면 트랜잭션을 거의 차례대로 실행 필요하지만 동시성 처리 성능이 매우 나빠짐.
* 격리성과 동시성의 문제로 인해 ANSI 표준은 트랜잭션의 격리 수준을 4단계로 나눔.

### 격리 수준 4단계

* 격리 수준은 아래 순서대로 위에서 아래로 갈수록 격리 수준이 높아짐.
* 격리 수준이 낮을수록 동시성은 증가하지만 격리 수준에 따라 다양한 문제 발생.
* 애플리케이션 대부분은 동시성 처리가 중요해서 보통 READ UNCOMMITTED를 기본으로 사용.
  * 일부 높은 격리 수준이 필요한 로직은 DB 트랜잭션이 제공하는 잠금 기능 사용.

1. READ UNCOMMITTED(커밋되지 않은 읽기)
2. READ COMMITTED(커밋된 읽기)
3. REPEATABLE READ(반복 가능한 읽기)
4. SERIALIZABLE(직렬화 가능)

### 트랜잭션 격리 수준과 문제점

|격리 수준|DIRTY READ|NON_REPEATABLE READ|PHANTOM READ|
|---|---|---|---|
|READ UNCOMMITTED|O|O|O|
|READ COMMITTED| |O|O|
|REPEATABLE READ| | |O|
|SERIALIZABLE| | | |

#### DIRTY READ

* 커밋하지 않은 데이터를 읽을 수 있음.
* 예시
  1. 트랜잭션1이 데이터 수정중이며 아직 커밋하지 않음.
  2. 트랜잭션2가 트랜잭션1이 아직 수정중인 데이터를 조회.
  3. 트랜잭션2가 DIRTY READ한 데이터를 사용시 트랜잭션1이 롤백하면 데이터 정합성 문제 발생.

#### NON-REPEATABLE READ
  
* 반복해서 같은 데이터를 읽을 수 없는 상태.
* 예시
  1. 트랜잭션1이 데이터 조회 중.
  2. 갑자기 트랜잭션2가 데이터를 수정하고 커밋.
  3. 트랜잭션1이 다시 조회시 수정된 데이터가 조회.
  
#### PHANTOM READ

* 반복 조회 시 결과 집합이 달라지는 것.
* 예시
  1. 트랜잭션1이 10살 이하의 회원을 조회. 
  2. 트랜잭션2가 5살 회원을 추가하고 커밋.
  3. 트랜잭션1이 다시 10살 이하의 회원을 조회하면 회원 하나가 추가된 상태로 조회. 
  
<br/>

# 낙관적 락과 비관적 락 기초

* 영속성 컨텍스트(1차 캐시)를 활용하면 READ COMMITTED 격리 수준이어도 애플리케이션 레벨에서 반복 가능한 읽기 가능.
  * 엔티티 가아닌 스칼라 값을 직접 조회(영속성 컨텍스트 관리 X)하는 경우는 불가.
* JPA는 DB 트랜잭션 격리 수준을 READ COMMITTED 정도로 가정.
  * 일부 로직에 더 높은 격리 수준이 필요하면 **낙관적 락**과 **비관적 락** 중 하나 사용.

## 낙관적 락 기초

* 트랜잭션 대부분이 충돌하지 않는다고 낙관적으로 가정하는 방법.
* DB가 제공하는 락 아닌 JPA가 제공하는 버전 관리 기능을 사용.
  * 쉽게 말해 애플리케이션이 제공하는 락.
* 트랜잭션을 커밋하기 전까지는 트랜잭션의 충돌을 알 수 없음.

## 비관적 락 기초

* 트랜잭션 충돌을 가정하고 우선 락을 걸고 보는 방법.
* DB가 제공하는 락을 사용.
  * 애표적으로 select for update 구문.

## 두 번의 갱신 분실 문제(second lost updates problem)

* 추가적으로 DB 트랜잭션 범위를 넘어서는 문제가 있음.
  * 트랜잭션만으로는 문제 해결 불가.
* 사용자 A와 사용자 B가 동시에 제목이 같은 공지사항을 수정한다고 가정.
  1. 둘이 동시에 수정 화면을 열어서 내용을 수정하는 중.
  2. A가 먼저 수정완료 버튼 실행.
  3. 잠시 후 B가 수정완료 버튼 실행.
  4. 먼저 완료한 A의 수정사항은 사라지고 B의 수정사항만 남음.
  
### 3가지 선택 사항

1. 마지막 커밋만 인정하기 (기본으로 사용)
   * 마지막에 커밋한 사용자 B의 내용만 인정.
2. 최초 커밋만 인정하기 
   * 사용자 B가 수정을 완료할 때 오류 발생.
   * 상황에 따라 최초 커밋만 인정하기가 더 합리적일 수 있음.
     * JPA가 제공하는 버전 관리 기능 사용시 쉽게 구현 가능. 
3. 충돌하는 갱신 내용 병합하기 
   * 사용자 A와 사용자 B의 수정사항 병합.
   * 최초 커밋만 인정하기를 조금 더 우아하게 처리하는 방법.
     * 애플리케이션 개발자가 직접 사용자를 위해 병합 방법 제공.
   
