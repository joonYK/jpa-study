# 트랜잭션과 격리 수준

## 트랜잭션의 ACID 보장

### 원자성(Atomicity)
* 트랜잭션 내에서 실행한 작업들은 하나의 작업인 것처럼 모두 성공하든가 모두 실패.

### 일관성(Consistency)
* 모든 트랜잭션은 일관성 있는 DB 상태 유지.
  * 예를 들어 DB 에서 정한 무결성 제약 조건을 항상 만족해야 함.

### 격리성(Isolation)
* 동시에 실행되는 트랜잭션들이 서로 영향을 미치지 않도록 격리.
  * 예를 들어 동시에 같은 데이터를 수정 못함.
* 동시성과 관련된 성능 이슈로 인해 격리 수준 선택.
 
### 지속성(Durability)
* 트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 함.
* 중간에 시스템에 문제가 생겨도 DB 로그 등으로 성공한 트랜잭션 내용 복구.

## 트랜잭션 격리 수준

* 트랜잭션 간에 격리성을 완벽히 보장하려면 트랜잭션을 거의 차례대로 실행 필요하지만 동시성 처리 성능이 매우 나빠짐.
* 격리성과 동시성의 문제로 인해 ANSI 표준은 트랜잭션의 격리 수준을 4단계로 나눔.

### 격리 수준 4단계

* 격리 수준은 아래 순서대로 위에서 아래로 갈수록 격리 수준이 높아짐.
* 격리 수준이 낮을수록 동시성은 증가하지만 격리 수준에 따라 다양한 문제 발생.
* 애플리케이션 대부분은 동시성 처리가 중요해서 보통 READ UNCOMMITTED를 기본으로 사용.
  * 일부 높은 격리 수준이 필요한 로직은 DB 트랜잭션이 제공하는 잠금 기능 사용.

1. READ UNCOMMITTED(커밋되지 않은 읽기)
2. READ COMMITTED(커밋된 읽기)
3. REPEATABLE READ(반복 가능한 읽기)
4. SERIALIZABLE(직렬화 가능)

### 트랜잭션 격리 수준과 문제점

|격리 수준|DIRTY READ|NON_REPEATABLE READ|PHANTOM READ|
|---|---|---|---|
|READ UNCOMMITTED|O|O|O|
|READ COMMITTED| |O|O|
|REPEATABLE READ| | |O|
|SERIALIZABLE| | | |

#### DIRTY READ

* 커밋하지 않은 데이터를 읽을 수 있음.
* 예시
  1. 트랜잭션1이 데이터 수정중이며 아직 커밋하지 않음.
  2. 트랜잭션2가 트랜잭션1이 아직 수정중인 데이터를 조회.
  3. 트랜잭션2가 DIRTY READ한 데이터를 사용시 트랜잭션1이 롤백하면 데이터 정합성 문제 발생.

#### NON-REPEATABLE READ
  
* 반복해서 같은 데이터를 읽을 수 없는 상태.
* 예시
  1. 트랜잭션1이 데이터 조회 중.
  2. 갑자기 트랜잭션2가 데이터를 수정하고 커밋.
  3. 트랜잭션1이 다시 조회시 수정된 데이터가 조회.
  
#### PHANTOM READ

* 반복 조회 시 결과 집합이 달라지는 것.
* 예시
  1. 트랜잭션1이 10살 이하의 회원을 조회. 
  2. 트랜잭션2가 5살 회원을 추가하고 커밋.
  3. 트랜잭션1이 다시 10살 이하의 회원을 조회하면 회원 하나가 추가된 상태로 조회. 
  