* JPQL을 자바 코드로 작성하도록 도와주는 빌더 클래스 API.
    * JPQL의 생성을 돕는 클래스 모음.
* 문법 오류를 컴파일 단계에서 체크하고 동적 쿼리를 안전하게 생성.
* 코드가 복잡하고 장황해서 직관적으로 이해하기 힘듦.

# 기초

* API는 javax.persistence.criteria 패키지에 존재.
* Criteria는 검색 조건부터 정렬까지 Criteria 빌더(CriteriaBuilder)를 사용해서 완성.

#### 예) 모든 회원 엔티티 조회

```java
//JPQL: select m from Member m

CriteriaBuilder cb = em.getCriteriaBuilder(); // 1. Criteria 쿼리 빌더
CriteriaQuery<Member> cq = cb.createQuery(Member.class); //2. Criteria 생성, 반환 타입 지정

Root<Member> m = cq.from(Member.class); //3. FROM 절
cq.select(m); //4. SELECT 절

TypedQuery<Member> query = em.createQuery(cq);
List<Member> members = query.getResultList();
```

1. Criteria 쿼리 생성을 위해 Criteria 빌더를 얻음.<br/>
   빌더는 EntityManager나 EntityManagerFactory에서 획득.
2. 쿼리 빌더에서 Criteria 쿼리 생성하고 반환 타입 지정 가능.
3. FROM 절 생성하고 반환된 값 m은 Criteria에서 사용하는 특별한 별칭.<br/>
   m을 조회의 시작점이라는 의미로 쿼리 루트라고 함.
4. SELECT 절 생성.

#### 예) 검색 조건 추가

```java
/* JPQL
 * select m from Member m
 * where m.username='회원1'
 * order by m.age desc
 */

CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> cq = cb.createQuery(Member.class);
Root<Member> m = cq.from(Member.class);

Predicate usernameEqual = cb.equal(m.get("username"), "회원1"); //1. 검색 조건 정의
javax.persistence.crieatie.Order ageDesc = cb.desc(m.get("age")); //2. 정렬 조건 정의

//3. 쿼리 생성
cq.select(m)
    .where(usernameEqual)
    .orderBy(ageDesc);

List<Member> resultList = em.createQuery(cq).getResultList();
```

1. m.get("username")에서 m은 회원 엔티티의 별칭이고 JPQL에서 m.username과 같은 표현.<br/>
cb.equal(A,B)는 A = B라는 뜻으로 cb.equal(m.get("username"), "회원1")은 JPQL로 m.username = '회원1'.
2. cb.desc(m.get("age"))는 JPQL로 m.age desc.
3. 만들어둔 조건으로 원하는 쿼리 생성.

#### 예) 숫자 타입 검색

```java
/* JPQL
 * select m from Member m
 * where m.age > 10 order by m.age desc
 */

...
Root<Member> m = cq.from(Member.class);

//타입 정보 필요.
//greaterThan 대신에 gt도 가능.
Predicate ageGt = cb.greaterThan(m.<Integer>get("age"), 10);

cq.select(m);
cq.where(ageGt);
cq.orderBy(cb.desc(m.get("age")));
```

* m.get("age")에서는 "age"의 타입 정보를 알지 못해서 제네릭으로 반환 타입 정보 명시.
* String 같은 문자 타입은 지정하지 않아도 됨.

### 쿼리 루트(Query Root)와 별칭

* Root<Member> m = cq.from(Member.class);에서 m이 쿼리 루트.
* 쿼리 루트는 조회의 시작점.
* Criteria에서 사용되는 특별한 별칭으로 JPQL의 별칭과 같음.
* 별칭은 엔티티에만 부여 가능.

### 경로 표현식

* m.get("username")은 JPQL의 m.username과 같음.
* m.get("team").get("name")은 JPQL의 m.team.name과 같음.

<br/>

# Criteria 쿼리 생성

### CriteriaBuilder

* CriteriaBuilder.createQUery() 메서드로 Criteria 쿼리(CriteriaQuery) 생성.

```java
public interface CriteriaBuilder {
    CriteriaQuery<Object> createQuery(); //조회값 반환 타입 : Object
    <T> CriteriaQuery<T> createQuery(Class<T> resultClass); //조회값 반환 타입 : 엔티티, 임베디드 타입, 기타
    CriteriaQuery<Tuple> createQuery(); //조회값 반환 타입 : Tuple
}
```

### 반환 타입 지정

* Criteria 쿼리 생성 시 파라미터로 쿼리 결과에 대한 반환 타입 지정 가능.

```java
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Member> cq = cb.createQuery(Member.class);
...
//위에서 Member 타입을 지정해서 따로 지정하지 않아도 Member 타입을 반환.
List<Member> resultList = em.createQuery(cq).getResultList(); 
```

### 반환 타입 미지정

* 반환 타입을 지정할 수 없거나 반환 타입이 둘 이상이면 Object로 반환.

```java
CriteriaQuery<Object> cq = cb.createQuery();
...
List<Object> resultList = em.createQuery(cq).getResultList();

//반환 타입이 둘 이상이면 Object[]를 사용하는 것이 편함
CriteriaQuery<Object[]> cq = cb.createQuery(Object[].class);
...
List<Object[]> resultList = em.createQuery(cq).getResultList();
```

### 튜플로 조회

```java
CriteriaQuery<Tuple> cq = cb.createQuery();
...
TypedQuery<Tuple> query = em.createQuery(cq);
```

<br/>

# 조회

### CriteriaQuery

```java
public interface CriteriaQuery<T> extends AbstractQuery<T> {
    CriteriaQuery<T> select(Selection<? extends T> selection); //한 건 지정
    CriteriaQuery<T> multiselect(Selection<?>... selections); //여러 건 지정
    CriteriaQuery<T> multiselect(List<Selection<?>> selectionList); //여러 건 지정
    ...
}
```

#### 조회 대상 한 건 지정

```java
cq.select(m) //JPQL : select m
```

#### 조회 대상 여러 건 지정

```java
//JPQL : select m.username, m.age
cq.multiselect(m.get("username"), m.get("age"));

//cb.array를 사용해서 지정
cq.select(cb.array(m.get("username"), m.get("age")));
```

### DISTINCT

```java
//JPQL : select distinct m.username, m.age
cq.multiselect(m.get("username"), m.get("age")).distinct(true);
```

### NEW, construct()

* JPQL에서 select new 생성자() 구문은 Criteria에서 cb.construct(클래스 타입, ...)로 사용.

```java
<Y> CompoundSelection<Y> construct(Class<Y> resultClass, Selection<?>... selections);
```

#### 예) Criteria construct()
```java
/* JPQL
 * select new jpabook.domain.MemberDTO(m.username, m.age)
 * from Member m
 */

CriteriaQuery<MemberDTO> cq = cb.createQuery(MemberDTO.class);
Root<Member> m = cq.from(Member.class);

cq.select(cb.construct(MemberDTO.class, m.get("username"), m.get("age")));

TypedQuery<MemberDTO> query = em.createQuery(cq);
List<MemberDTO> resultList = query.getResultList();
```

### 튜플

* Criteria에는 Map과 비슷한 튜플이라는 반환 객체를 제공.

#### 예) 튜플 사용

```java
// JPQL : select m.username, m.age from Member m

CriteriaQuery<Tuple> cq = cb.createTupleQuery();
//CriteriaQuery<Tuple> cq = cb.createQuery(Tuple.class);

Root<Member> m = cq.from(Member.class);
cq.multiselect(
        m.get("username").alias("username"), //튜플에서 사용할 튜플 별칭
        m.get("age").alias("age")
);

TypedQuery<Tuple> query = em.createQuery(cq);
List<Tuple> resultList = query.getResultList();
for(Tuple tuple : resultList) {
    String username = tuple.get("username", String.class); //튜플 별칭으로 조회
    Integer age = tuple.get("age", Integer.class);
}
```

* 튜플은 튜플의 검색 키로 사용할 튜플 전용 별칭을 필수로 할당 필요.
    * alias() 메소드를 사용해 지정.
* 선언해둔 튜플 별칭으로 데이터를 조회.
* 튜플 별칭으로 인해 실제 SQL에 별칭이 달리진 않음. Map과 비슷한 구조라서 별칭을 키로 사용.

#### 튜플 장점

* 튜플은 이름 기반이므로 순서 기반의 Object[]보다 안전.
* tuple.getElements() 같은 메소드를 사용해서 현재 튜플의 별칭과 자바 타입도 조회 가능.

#### 예) 엔티티 조회

* 튜플로 엔티티 조회도 가능하며 별칭은 필수.

```java
CriteriaQuery<Tuple> cq = cb.createTupleQuery();
Root<Member> m = cq.from(Member.class);
cq.select(cb.tuple( //cq.multiselect(...) 메소드와 같은 기능.
    m.alias("m"), //회원 엔티티, 별칭 m
    m.get("username").alias("username") // 단순 값 조회, 별칭 username
));

TypedQuery<Tuple> query = em.createQuery(cq);
List<Tuple> resultList = query.getResultList();
for(Tuple tuple : resultList) {
    Member member = tuple.get("m", Member.class),
    String username = tuple.get("username", String.class);
}
```

# 집합

## GROUP BY

#### 예) 팀 이름별로 나이가 가장 많은 사람과 적은 사람 조회

```java
/* JPQL
 * select m.team.name, max(m.age), min(m.age)
 * from Member m
 * group by m.team.name
 */

CriteriaQuery<Object[]> cq = cb.createQuery(Object[].class);
Root<Member> m = cq.from(Member.class);

Expression maxAge = cb.max(m.<Integer>get("age"));
Expression minAge = cb.min(m.<Integer>get("age"));

cq.multiselect(m.get("team").get("name"), maxAge, minAge);
cq.groupBy(m.get("team").get("name")); // JPQL : group by m.team.name
...
```

## HAVING

#### 예) GROUP BY 예제에서 팀에 가장 나이 어린 사람이 10살을 초과하는 팀 조회.

```java
cq.multiselect(m.get("team").get("name"), maxAge, minAge)
    .groupBy(m.get("team").get("name"))
    .having(cb.gt(minAge, 10)); // JPQL : having min(m.age) > 10
```