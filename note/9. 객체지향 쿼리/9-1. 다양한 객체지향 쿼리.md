### EntityManager.find() 조회의 한계

* find는 식별자로 특정 엔티티 하나를 조회.
    * 객체 그래프 탐색으로 연관된 엔티티들을 조회해 나감.
    * 하지만 30살 이상인 회원 모두 검색과 같은 경우 조회가 힘듬.
    
### 엔티티 객체를 대상으로 검색하는 방법 등장 (JPQL)

* ORM을 사용하면 테이블이 아닌 엔티티 객체를 대상으로 개발.
* 검색도 테이블이 아닌 `엔티티 객체를 대상으로 하는 방법이 필요`.
* 이런 문제를 해결하기 위해 `JPQL`이란 기술 등장. 
    * 테이블이 아닌 `엔티티 객체를 대상으로 검색`하는 객체지향 쿼리.
        * `객체지향 SQL`로 정의할 수 있음. 
    * SQL을 추상화해서 `특정 DB SQL에 의존하지 않음`.
    * JPA가 JPQL을 분석해서 적절한 SQL을 만듦.

### JPQL외의 다양한 검색 방법

#### Criteria

* JPQL을 생성하는 빌더 클래스.
* `문자가 아닌 프로그래밍 코드로 JPQL을 작성`할 수 있음.
    * JPQL 문법 오타로 인한 런타임 시점에 발생하는 오류 방지.
    * 컴파일 시점에 오류 발견 가능.
    * IDE로 코드 자동 완성 가능 지원.
    * 동적 쿼리 작성이 용이.
    * 복잡하고 장황하여 사용이 불편한 단점이 있음.
  
#### QueryDSL

* `Criteria처럼 JPQL 빌더 역할` 수행.
* 코드 기반이면서 단순하고 사용하기 쉬움.
* 코드도 JPQL과 비슷해서 알아보기 쉬움.

#### 네이티브 SQL

* JPA는 `SQL을 직접 사용`할 수 있는 기능도 지원.
* 가끔 특정 DB에 의존하는 기능을 사용해야 할 때가 있음.
    * SQL은 지원하지만 JPQL은 지원하지 않는 기능.
* 특정 DB에 의존되어 DB를 변경하면 SQL도 수정해야 하는 단점 존재.    

#### JDBC 또는 MyBatis 같은 프레임워크 사용.

* JPA 구현체가 제공하는 방법을 통해 JDBC 커넥션을 획득해서 사용.
* JDBC나 MyBatis를 함께 사용하면 `영속성 컨텍스트를 적절한 시점에 강제로 플러시` 해야함.
    * 모두 JPA를 우회해서 DB에 접근하므로 JPA가 전혀 인식하지 못함.
    * 영속성 컨텍스트와 DB가 불일치 상태로 되어 데이터 무결성을 해칠 수 있음.