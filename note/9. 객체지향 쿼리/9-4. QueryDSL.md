* Criteria는 너무 복잡하고 어렵다는 단점이 있음.
* QueryDSL은 코드로 작성해도 쉽고 간결하며 그 모양도 쿼리와 비슷하게 개발할 수 있음.
    * Criteria가 가지는 장점에 더해서 쉽고 단순함.
* QueryDSL은 이름 그대로 데이터를 조회하는 데 기능이 특화되어 있음.

# QueryDSL 설정

### 필요 라이브러리

* QueryDSL 라이브러리를 추가.

#### pom.xml 추가

```xml
<dependency>
    <groupId>com.querydsl</groupId>
    <artifactId>querydsl-apt</artifactId>
    <version>${querydsl.version}</version>
    <scope>provided</scope>
</dependency>

<dependency>
<groupId>com.querydsl</groupId>
<artifactId>querydsl-jpa</artifactId>
<version>${querydsl.version}</version>
</dependency>
```

### 환경설정

* Criteria의 메타 모델처럼 엔티티를 기반으로 쿼리 타입이라는 쿼리용 클래스 생성.

#### 쿼리 타입 생성용 pom.xml 추가

```xml
<project>
    <build>
        <plugins>
            <plugin>
                <groupId>com.mysema.maven</groupId>
                <artifactId>apt-maven-plugin</artifactId>
                <version>1.1.3</version>
                <executions>
                    <execution>
                        <goals>
                            <goal>process</goal>
                        </goals>
                        <configuration>
                            <outputDirectory>target/generated-sources/java</outputDirectory>
                            <processor>com.querydsl.apt.jpa.JPAAnnotationProcessor</processor>
                        </configuration>
                    </execution>
                </executions>
            </plugin>
            ...
        </plugins>
    </build>
</project>
```

* 콘솔에서 mnv compile 입력시 outputDirectory에 지정한 target/generated-sources 위치에<br/>
  QMember.class처럼 Q로 시작하는 쿼리 타입을 생성.

<br/>

# 시작

#### QueryDSL 시작

```java
public void queryDSL() {
    EntityManager em = emf.createEntityManager();

    JPAQuery<Member> query = new JPAQuery<>(em);
    QMember qMember = new QMember("m"); //생성되는 JPQL의 별칭이 m

    List<Member> members = query.from(qMember)
        .where(qMember.username.eq("유저1"))
        .orderBy(qMember.username.desc())
        .fetch();
}
```

1. 우선 com.querydsl.jpa.impl.JPAQuery 객체를 생성. (엔티티 매니저 생성자로 전달)
2. 쿼리 타입(Q)을 생성하고 생성자에 별칭을 전달. (JPQL에서 별칭으로 사용)
3. 그 다음 from, where, orderBy 사용.

### 기본 Q 생성

* 쿼리 타입(Q)은 사용하기 편리하도록 아래와 같이 기본 인스턴스 보관.
* 같은 엔티티를 조인하거나 서브쿼리에 사용하면 같은 별칭이 사용되므로 별칭을 직접 지정해서 사용 필요.

#### Member 쿼리 타입

```java
public class QMember extends EntityPathBase<Member> {
    public static final QMember member = new QMember("member1");
    ...
}

    //쿼리 타입 사용
    QMember qMember = new QMember("m"); //직접 지정
    QMember qMember = QMember.member; //기본 인스턴스 사용
```

# 검색 조건 쿼리

#### 예) 기본 쿼리 기능

```java
JPAQuery<Product> query = new JPAQuery<>(em);
QProduct product = QProduct.product;
List<Product> list = query.from(product)
    .where(product.name.eq("상품10").and(product.price.gt(20000)))
    .fetch(); //조회할 프로젝션 지정
```

#### 생성된 JPQL

```sql
select product
from Product product
where product.name = ?1 and product.price > ?2
```

* QueryDSL의 where 절에는 and나 or 사용 가능.
* 아래처럼 and 연산으로 여러 검색 조건을 사용해도 됨.
```
.where(product.name.eq("상품10"), and(product.price.gt(20000)))
```

* 쿼리 타입의 필드는 필요한 대부분의 메소드를 명시적으로 제공.
* 아래는 where()에서 사용되는 메소드.
```java
product.price.between(10000, 20000); //가격이 10,000 ~ 20,000원 상품
product.name.contains("상품1"); //상품1이라는 이름을 포함한 상품. SQL : like '%상품1%' 검색
product.name.startsWith("고급"); //이름이 고급으로 시작하는 상품. SQL : like '고급%' 검색
```

<br/>

# 결과 조회

* 쿼리 작성 이후 결고 조회 메소드를 호출하면 실제 DB를 조회.
* 보통 fetchOne()나 fetch()를 사용하고 파라미터로 프로젝션 대상을 넘김.
* 결과 조회 API는 com.querydsl.core.Fetchable에 정의되어 있음.

#### 대표적인 결과 조회 메소드

* fetchOne() : 조회 결과가 한 건일 때 사용. <br/>
  조회 결과가 없으면 null 반환, 하나 이상이면 com.querydsl.core.NonUniqueResultException 예외 발생.
* fetchFirst() : fetchOne()과 같지만 결과가 하나 이상이면 처음 데이터 반환.
* fetch() : 결과가 하나 이상일 때 사용. 결과가 없으면 빈 컬렉션 반환.

<br/>

# 페이징과 정렬

#### 페이징과 정렬

```java
QProduct product = QProduct.product;

List<Product> list = query.from(product)
    .where(product.price.gt(2000))
    .orderBy(product.price.desc(), product.stockAmount.asc())
    .offset(10).limit(20)
    .fetch();
```

* 정렬은 orderBy를 사용, 쿼리 타입(Q)이 제공하는 asc(), desc()를 사용.
* 페이징은 offset과 limit를 적절히 조합.

#### QueryModifiers를 파라미터로 사용.

* restrict() 메소드에 com.querydsl.core.QueryModifiers를 파라미터로 사용 가능.

```java
QueryModifiers queryModifiers = new QueryModifiers(20L, 10L); //limit, offset
List<Product> list = query.from(qProduct)
    .restrict(queryModifiers)
    .fetch();
```

#### 페이징과 정렬 QueryResults() 사용

* 실제 페이징 처리를 하려면 검색된 전체 데이터 수를 알아야 함.
    * fetch() 대신에 fetchResults()를 사용.
    
```java
JPAQuery<Product> query = new JPAQuery<>(em);
QProduct qProduct = QProduct.product;

QueryResults<Product> results = query.from(qProduct)
        .where(qProduct.price.gt(2000))
        .offset(10).limit(20)
        .fetchResults();

long total = results.getTotal(); //검색된 전체 데이터 수
long limit = results.getLimit();
long offset = results.getOffset();
List<Product> list = results.getResults(); //조회된 데이터
```

* fetchResults()를 사용하면 전체 데이터 조회를 위한 count 쿼리를 한 번 더 실행.