# 특징

* 객체지향 쿼리 언어로 테이블이 아닌 엔티티 객체를 대상으로 쿼리.
* SQL을 추상화해서 특정 DB에 의존하지 않음.
* 최종적으로 SQL로 변환됨.

<br/>

# 기본 문법

* SQL과 비슷하게 SELECT, UPDATE, DELETE 문을 사용.
* 엔티티 저장은 persist() 메서드를 사용하므로 INSERT 문은 따로 없음.
* 문법의 구조가 SQL과 비슷함.

## SELECT

* SELECT 문 예제
```SQL
SELECT m FROM Member AS m where m.username = 'Hello'
```

#### 특징

* 대소문자 구문
    * Member, username은 대소문자를 구분.
    * SELECT, FROM, AS 같은 JPQL 키워드는 대소문가 구분 안 함.
* 엔티티 이름
    * Member는 클래스 명이 아니라 엔티티 명.
    * 엔티티 명은 @Entity로 지정하고 생략시 클래스 명이 사용됨.
        * 클래스 명을 엔티티 명으로 사용하는것을 추천.
* 별칭은 필수
    * Member AS m처럼 별칭을 필수로 사용. (AS 생략 가능)
    
## TypeQuery, Query

* JPQL을 실행하려면 쿼리 객체 생성 필요.
* TypeQuery는 반환할 타입을 명확하게 지정 가능.
* Query는 반환 타입을 명확하게 지정할 수 없을때 사용.

#### TypeQuery

```java
TypedQuery<Member> query = em.createQuery("SELECT m FROM Member m", Member.class);

List<Member> resultList = query.getResultList();
for (Member member : resultList) {
    System.out.println("member = " + member);    
}
```

#### Query

```java
Query query = em.createQuery("SELECT m.username, m.age from Member m");
List resultList = query.getResultList();

for (Object o : resultList) {
    object[] result = (Object[]) 0;
    System.out.println("username = " + result[0]);
    System.out.println("age = " + result[1]);
}
```

* 조회 대상이 String 타입인 회원 이름과 Integer 타입인 나이로 조회 대상 타입이 명확하지 않음.
* 여러 엔티티나 컬럼을 선택할 때는 반환할 타임이 명확하지 않아 Query 객체 사용.

#### 결과 조회

* query.getResultList()
    * 결과를 위의 방법으로 반환.
    * 결과가 없으면 빈 컬렉션 반환.
* query.getSingleResult()
    * 결과가 하나일 때 사용.
    * 결과 없으면 javax.persistence.NoResultException 예외 발생.
    * 결과가 1개보다 많으면 javax.persistence.NonUniqueResultException 예외 발생.

<br/>
    
# 파라미터 바인딩

* JDBC는 위치 기준 파라미터 바인딩만 지원하지만 JPQL은 이름 기준 파라미터 바인딩도 지원.
* 이름 기준 파라미터 바인딩 방식을 사용하는 것이 더 명확함.

### 이름 기준 파라미터

* 앞에 :를 사용해서 구분.

```java
String usernameParam = "User1";

TypedQuery<Member> query = em.createQuery(
        "SELECT m FROM Member m where m.username = :username", Member.class);
        
query.setParameter("username", usernameParam);
List<Member> resultList = query.getResultList();
```

* 메소드 체인 방식으로 연속 작성 가능.

```java
List<Member> members = em.createQuery(
        "SELECT m FROM Member m where m.username = :username", Member.class)
            .setParameter("username", usernameParam)
            .getResultList();
```

### 위치 기준 파라미터

* ? 다음에 위치 값 지정.

```java
List<Member> members = em.createQuery(
        "SELECT m FROM Member m where m.username = ?1", Member.class)
            .setParameter(1, usernameParam)
            .getResultList();
```

### ※ 파라미터 바인딩 방식을 지향

```java
"select m from Member m where m.username = "'" + usernameParam + "'"
```

* 위 처럼 직접 문자를 더해 만들어 넣으면 문제가 발생.
    * SQL 인젝션 공격의 가능성.
    * 성능 이슈.
        * 파라미터 바인딩을 사용하면 파라미터가 달라져도 같은 쿼리로 인식.
        * JPA는 JPQL을 SQL로 파싱한 결과를 재사용할 수 있으며 DB도 마찬가지.
        