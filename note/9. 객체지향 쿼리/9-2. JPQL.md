# 특징

* 객체지향 쿼리 언어로 테이블이 아닌 엔티티 객체를 대상으로 쿼리.
* SQL을 추상화해서 특정 DB에 의존하지 않음.
* 최종적으로 SQL로 변환됨.

<br/>

# 기본 문법

* SQL과 비슷하게 SELECT, UPDATE, DELETE 문을 사용.
* 엔티티 저장은 persist() 메서드를 사용하므로 INSERT 문은 따로 없음.
* 문법의 구조가 SQL과 비슷함.

## SELECT

* SELECT 문 예제
```SQL
SELECT m FROM Member AS m where m.username = 'Hello'
```

#### 특징

* 대소문자 구문
    * Member, username은 대소문자를 구분.
    * SELECT, FROM, AS 같은 JPQL 키워드는 대소문가 구분 안 함.
* 엔티티 이름
    * Member는 클래스 명이 아니라 엔티티 명.
    * 엔티티 명은 @Entity로 지정하고 생략시 클래스 명이 사용됨.
        * 클래스 명을 엔티티 명으로 사용하는것을 추천.
* 별칭은 필수
    * Member AS m처럼 별칭을 필수로 사용. (AS 생략 가능)
    
## TypeQuery, Query

* JPQL을 실행하려면 쿼리 객체 생성 필요.
* TypeQuery는 반환할 타입을 명확하게 지정 가능.
* Query는 반환 타입을 명확하게 지정할 수 없을때 사용.

#### TypeQuery

```java
TypedQuery<Member> query = em.createQuery("SELECT m FROM Member m", Member.class);

List<Member> resultList = query.getResultList();
for (Member member : resultList) {
    System.out.println("member = " + member);    
}
```

#### Query

```java
Query query = em.createQuery("SELECT m.username, m.age from Member m");
List resultList = query.getResultList();

for (Object o : resultList) {
    object[] result = (Object[]) 0;
    System.out.println("username = " + result[0]);
    System.out.println("age = " + result[1]);
}
```

* 조회 대상이 String 타입인 회원 이름과 Integer 타입인 나이로 조회 대상 타입이 명확하지 않음.
* 여러 엔티티나 컬럼을 선택할 때는 반환할 타임이 명확하지 않아 Query 객체 사용.

#### 결과 조회

* query.getResultList()
    * 결과를 위의 방법으로 반환.
    * 결과가 없으면 빈 컬렉션 반환.
* query.getSingleResult()
    * 결과가 하나일 때 사용.
    * 결과 없으면 javax.persistence.NoResultException 예외 발생.
    * 결과가 1개보다 많으면 javax.persistence.NonUniqueResultException 예외 발생.

<br/>
    
# 파라미터 바인딩

* JDBC는 위치 기준 파라미터 바인딩만 지원하지만 JPQL은 이름 기준 파라미터 바인딩도 지원.
* 이름 기준 파라미터 바인딩 방식을 사용하는 것이 더 명확함.

### 이름 기준 파라미터

* 앞에 :를 사용해서 구분.

```java
String usernameParam = "User1";

TypedQuery<Member> query = em.createQuery(
        "SELECT m FROM Member m where m.username = :username", Member.class);
        
query.setParameter("username", usernameParam);
List<Member> resultList = query.getResultList();
```

* 메소드 체인 방식으로 연속 작성 가능.

```java
List<Member> members = em.createQuery(
        "SELECT m FROM Member m where m.username = :username", Member.class)
            .setParameter("username", usernameParam)
            .getResultList();
```

### 위치 기준 파라미터

* ? 다음에 위치 값 지정.

```java
List<Member> members = em.createQuery(
        "SELECT m FROM Member m where m.username = ?1", Member.class)
            .setParameter(1, usernameParam)
            .getResultList();
```

### ※ 파라미터 바인딩 방식은 선택이 아닌 필수

```java
"select m from Member m where m.username = "'" + usernameParam + "'"
```

* 위 처럼 직접 문자를 더해 만들어 넣으면 문제가 발생.
    * SQL 인젝션 공격의 가능성.
    * 성능 이슈.
        * 파라미터 바인딩을 사용하면 파라미터가 달라져도 같은 쿼리로 인식하므로
          JPA는 JPQL을 SQL로 파싱한 결과를 재사용 수 있음.
          
<br/>

# 프로젝션

* SELECT 절에 조회할 대상을 지정하는 것.
* [SELECT {프로젝션 대상} FROM]으로 대상을 선택.
* 대상은 엔티티, 임베디드 타입, 스칼라 타입(숫자, 문자 등 기본 데이터 타입).

### 1. 엔티티 프로젝션

```java
SELECT m FROM Member m
SELECT m.team FROM Member m
```

* 처음은 회원, 두 번쨰는 회원과 연관된 팀을 조회.
    * 둘 다 엔티티를 프로젝션 대상으로 사용.
* 원하는 객체를 바로 조회한 것으로 컬럼을 나열해서 조회하는 SQL과 차이가 있음.

### 2. 임베디드 타입 프로젝션

* JPQL에서 임베디드 타입은 엔티티와 거의 비슷하게 사용.
* 조회의 시작점이 될 수 없는 제약이 존재.

#### - 조회의 시작점으로 사용불가

* Address가 임베디드 타입이라고 할 때, 조회의 시작점으로 사용된 잘못된 쿼리.

```java
String query = "SELECT a FROM Address a";
```

#### - 엔티티를 통해서 임베디드 타입 조회

```java
String query = "SELECT o.address FROM Order o";
List<Address> addresses = em.createQuery(query, Address.class).getResultList();
```

### 3. 스칼라 타입 프로젝션

* 숫자, 문자, 날짜와 같은 기본 데이터 타입들을 스칼라 타입이라고 함.

```java
List<String> usernames = em.createQuery("SELECT username FROM Member m", String.class)
        .getResultList(); // 전체 회원 이름 조회(문자열)
```

#### - 중복 데이터 제거

```java
SELECT DISTINCT username FROM Member m
```

#### - 통계 쿼리

```java
Double orderAmountAvg = em.createQuery("SELECT AVG(o.orderAmount) FROM Order o", Double.class)
        .getResultList();
```

### 4. 여러 값 조회

* 엔티티가 아닌 꼭 필요한 데이터들만 선택해서 조회해야 할 때 사용.

#### - 스칼라 타입만 조회

```java
List<Object[]> resultList = em.createQuery("SELECT m.username, m.age FROM Member m")
    .getResultList();

for (Object[] row : resultList) {
    String username = (String) row[0];
    Integer age (Integer) row[1];
}
```

#### - 엔티티 타입과 스칼라 타입 조회

```java
List<Object[]> resultList = em.createQuery(
        "SELECT o.member, o.product, o.orderAmount FROM Order o").getResultList();

for (Object[] row : resultList) {
    Member member = (Member) row[0]; //엔티티
    Product product = (Product) row[1]; //엔티티
    int orderAmount = (Integer) row[2]; //스칼라
}
```

### 5. NEW 명령어

* 보통 UserDTO처럼 의미 있는 객체를 사용.
* NEW 명령어를 사용해서 조회 데이터를 객체로 변환하는 작업을 생략 가능.

```java
TypedQuery<UserDTO> query = em.createQuery(
        "SELECT new jpabook.jpql.UserDTO(m.username, m.age) FROM Member m", UserDTO.class);
List<UserDTO> resultList = query.getResultList();
```

* 위 처럼 SELECT 다음에 NEW 명령어로 반환받을 클래스를 지정.
* 지정한 클래스의 생성자에 JPQL 조회 결과를 넘겨줄 수 있음.
* 주의 사항
    1. 패키지 명을 포함한 전체 클래스 명을 입력.
    2. 순서와 타입이 일치하는 생성자가 필요.

<br/>

# 페이징 API

* DB마다 페이징 처리 SQL이 달라서 JPA는 페이징을 두 API로 추상화 함.
    * setFirstResult(int startPosition) : 조회 시작 위치(0부터 시작)
    * setMaxResults(int maxResult) : 조회할 데이터 수
  
### 페이징 사용 예제

```java
TypedQuery<Member> query = em.createQuery(
        "SELECT m FROM Member m ORDER BY m.username DESC", Member.class);

query.setFirstResult(10);
query.setMaxResults(20);
query.getResultList();
```

* FristResult의 시작이 10으로 11번째부터 총 20건의 데이터를 조회. (11 ~ 30번 데이터)

### 데이터베이스별 페이징 쿼리 결과

* 데이터베이스 방언(Dialect) 덕분에 DB마다 다른 페이징 처리를 같은 API로 처리 가능.

#### HSQLDB(org.hibernate.dialect.HSQLDialect)

```sql
SELECT
    M.ID AS ID,
    M.AGE AS AGE,
    M.TEAM_ID AS TEAM_ID,
    M.NAME AS NAME
FROM
    MEMBER M
ORDER BY
    M.NAME DESC OFFSET ? LIMIT ?
```

#### MYSQL(org.hibernate.dialect.MySQL5InnoDBDialect)

```sql
SELECT
    M.ID AS ID,
    M.AGE AS AGE,
    M.TEAM_ID AS TEAM_ID,
    M.NAME AS NAME
FROM
    MEMBER M
ORDER BY
    M.NAME DESC LIMIT ?, ?
```

#### PostgreSQL(org.hibernate.dialect.PostgreSQL82Dialect)

```sql
SELECT
    M.ID AS ID,
    M.AGE AS AGE,
    M.TEAM_ID AS TEAM_ID,
    M.NAME AS NAME
FROM
    MEMBER M
ORDER BY
    M.NAME DESC LIMIT ? OFFSET ?
```

#### Oracle(org.hibernate.dialect.Oracle10gDialect)

```sql
SELECT *
FROM
    ( SELECT ROW_.*, ROWNUM ROWNUM_
      FROM
        ( SELECT
             M.ID AS ID,
             M.AGE AS AGE,
             M.TEAM_ID AS TEAM_ID,
             M.NAME AS NAME
          FROM Member M
          ORDER BY M.NAME  
        ) ROW_
      WHERE ROWNUM <= ?
    )
WHERE ROWNUM_ > ?
```

<br/>

# 집합과 정렬

* 집합은 집합함수와 함께 통계 정보를 구할 때 사용.

## 집합 함수

|함수|설명|
|---|---|
|COUNT|결과 수를 구함. <br/> 반환 타임: Long|
|MAX, MIN|최대, 최소 값을 구함. <br/> 문자, 숫자, 날짜 등에 사용.|
|AVG|평균값을 구함. <br/> 숫자 타입만 사용. <br/> 반환 타입: Double|
|SUM|합을 구함. <br/> 숫자 타입만 사용. <br/> 반환 타입 <br/> * 정수합 Long <br/> * 소수합 Double <br/> * BigInteger합 BigInteger <br/> * BigDecimal합 BigDecimal|

### 집합 함수 사용 시 참고사항

* NULL 값은 무시하므로 통계 잡히지 않음.
    * DISTINCT도 무시.
* 값이 없는데 함수를 사용하면 NULL 값이 됨.
    * 단, COUNT는 0이 됨.
* DISTINCT를 집합 함수 안에 사용해서 중복된 값을 제거하고 집합을 구할 수 있음.
    * select COUNT(DISTINCT m.age) from Member m
* DISTINCT를 COUNT에서 사용할 때 임베디드 타입 미지원.  

## GROUP BY, HAVING

### GROUP BY

* GROUP BY는 통계 데이터를 구할 때 특정 그룹끼리 묶음.

```java
// 팀 이름을 기준으로 그룹별로 묶어서 통계 데이터 구함.
select t.name, COUNT(m.age), SUM(m.age), AVG(m.age), MAX(m.age), MIN(m.age)
from Member m LEFT JOIN m.team t
GROUP BY t.name
```

### HAVING

* GROUP BY와 함께 사용하며 그룹화한 통계 데이터를 기준으로 필터링.

```java
// 팀 이름별 그룹중에서 평균나이가 10살 이상인 그룹 조회.
select t.name, COUNT(m.age), SUM(m.age), AVG(m.age), MAX(m.age), MIN(m.age)
from Member m LEFT JOIN m.team t
GROUP BY t.name
HAVING AVG(m.age) >= 10
```

### 정리

* 이런 쿼리들을 보통 리포팅 쿼리나 통계 쿼리라고 함.
* 통계 쿼리는 보통 전체 데이터를 기준으로 처리해서 실시간으로 사용하기엔 부담이 큼.
* 결과가 많다면 통계 결과만 저장하는 테이블을 별도로 만들어 사용자가 적은 새벽 시간에 집계 후 저장해놓는것이 좋음.

## 정렬(ORDER BY)

* 결과 정렬 시 사용.
* 문법 : ORDER BY {상태필드 경로 | 결과 변수 [ASC | DESC]}+
    * ASC : 오름차순
    * DESC : 내림차순
    * 상태필드는 t.name과 같이 객체의 상태를 나타내는 필드.
    * 결과 변수는 SELECT 절에 나타나는 값. (아래의 cnt)
    
```java
select t.name, COUNT(m.age) as cnt
from Member m LEFT JOIN m.team t
GROUP BY t.name
ORDER BY cnt
```

<br/>

# JPQL 조인

## 내부 조인

* INNER JOIN을 사용하고, INNER는 생략 가능.

### JPQL과 변환된 SQL 예제

```java
String teamName = "팀A";
// 회원이 가지고 있는 연관 필드로 팀과 조인
String query = "SELECT m FROM Member m INNER JOIN m.team t " +
        "WHERE t.name = :teamName";

List<Member> members = em.createQuery(query, Member.class)
    .setParameter("teamName", teamName)
    .getResultList();
```

```sql
SELECT
    M.ID AS ID,
    M.AGE AS AGE,
    M.TEAM_ID AS TEAM_ID,
    M.NAME AS NAME
FROM
    MEMBER M INNER JOIN TEAM T ON M.TEAM_ID=T.ID
WHERE
    T.NAME=?
```

* JPQL 조인은 연관 필드를 사용.
    * m.team이 연관 필드로 다른 엔티티와 연관관계를 가지기 위해 사용하는 필드.
    * JPQL 조인을 SQL 조인처럼 사용하면 문법 오류 발생.
  
### 조인한 두 개의 엔티티를 조회

```java
STring query = "SELECT m, t FROM Member m JOIN m.team t"; 
List<Object[]> result = em.createQuery(query).getResultList();

for (Object[] row : result) {
    Member member = (Member) row[0];
    Team team = (Team) row[1];
}
```

## 외부 조인

* 기능상 SQL의 외부 조인과 같음.

#### JPQL

```
SELECT m
FROM Member m LEFT [OUTER] JOIN m.team t
```

#### 변환된 SQL

```sql
SELECT
    M.ID AS ID,
    M.AGE AS AGE,
    M.TEAM_ID AS TEAM_ID,
    M.NAME AS NAME
FROM
    MEMBER M LEFT OUTER JOIN TEAM T ON M.TEAM_ID=T.ID
WHERE
    T.NAME=?
```

## 컬렉션 조인

* 일대다 관계나 다대다 관계처럼 컬렉션을 사용하는 곳에 사용.

```
SELECT t, m FROM Team t LEFT JOIN t.members m
```
t LEFT JOIN t.members는 팀과 팀이 보유한 회원목록을 `컬렉션 값 연관 필드`로 외부 조인.

## 세타 조인

* WHERE 절을 사용해 세타 조인을 하며 내부 조인만 지원함.
* 세타 조인을 사용하면 전혀 관계없는 엔티티도 조인할 수 있음.

#### JPQL

```
회원 이름이 팀 이름과 똑같은 사람 수를 구함

select count(m) from Member m, Team t
where m.username = t.name
```

#### 변환된 SQL

```sql
SELECT COUNT(M.ID)
FROM MEMBER M CROSS JOIN TEAM T
WHERE M.USERNAME=T.NAME
```

## JOIN ON 절(JPA 2.1)

* JPA 2.1부터 조인 시 ON 절을 지원.
* 조인 대상을 필터링하고 조인할 수 있음.
* 내부 조인의 ON 절은 WHERE 절을 사용할 때와 결과가 같으므로 보통 외부 조인에서만 사용.

#### JPQL

```
모든 회원을 조회하면서 회원과 연관된 팀도 조회

select m, t from Member m
left join m.team t on t.name = 'A'
```

#### 변환된 SQL

```sql
SELECT m.*, t.* FROM Member m
LEFT JOIN Team t ON m.TEAM_ID=t.id and t.name='A'
```