# 특징

* 객체지향 쿼리 언어로 테이블이 아닌 엔티티 객체를 대상으로 쿼리.
* SQL을 추상화해서 특정 DB에 의존하지 않음.
* 최종적으로 SQL로 변환됨.

<br/>

# 기본 문법

* SQL과 비슷하게 SELECT, UPDATE, DELETE 문을 사용.
* 엔티티 저장은 persist() 메서드를 사용하므로 INSERT 문은 따로 없음.
* 문법의 구조가 SQL과 비슷함.

## SELECT

* SELECT 문 예제
```SQL
SELECT m FROM Member AS m where m.username = 'Hello'
```

#### 특징

* 대소문자 구문
    * Member, username은 대소문자를 구분.
    * SELECT, FROM, AS 같은 JPQL 키워드는 대소문가 구분 안 함.
* 엔티티 이름
    * Member는 클래스 명이 아니라 엔티티 명.
    * 엔티티 명은 @Entity로 지정하고 생략시 클래스 명이 사용됨.
        * 클래스 명을 엔티티 명으로 사용하는것을 추천.
* 별칭은 필수
    * Member AS m처럼 별칭을 필수로 사용. (AS 생략 가능)
    
## TypeQuery, Query

* JPQL을 실행하려면 쿼리 객체 생성 필요.
* TypeQuery는 반환할 타입을 명확하게 지정 가능.
* Query는 반환 타입을 명확하게 지정할 수 없을때 사용.

#### TypeQuery

```java
TypedQuery<Member> query = em.createQuery("SELECT m FROM Member m", Member.class);

List<Member> resultList = query.getResultList();
for (Member member : resultList) {
    System.out.println("member = " + member);    
}
```

#### Query

```java
Query query = em.createQuery("SELECT m.username, m.age from Member m");
List resultList = query.getResultList();

for (Object o : resultList) {
    object[] result = (Object[]) 0;
    System.out.println("username = " + result[0]);
    System.out.println("age = " + result[1]);
}
```

* 조회 대상이 String 타입인 회원 이름과 Integer 타입인 나이로 조회 대상 타입이 명확하지 않음.
* 여러 엔티티나 컬럼을 선택할 때는 반환할 타임이 명확하지 않아 Query 객체 사용.

#### 결과 조회

* query.getResultList()
    * 결과를 위의 방법으로 반환.
    * 결과가 없으면 빈 컬렉션 반환.
* query.getSingleResult()
    * 결과가 하나일 때 사용.
    * 결과 없으면 javax.persistence.NoResultException 예외 발생.
    * 결과가 1개보다 많으면 javax.persistence.NonUniqueResultException 예외 발생.

<br/>
    
# 파라미터 바인딩

* JDBC는 위치 기준 파라미터 바인딩만 지원하지만 JPQL은 이름 기준 파라미터 바인딩도 지원.
* 이름 기준 파라미터 바인딩 방식을 사용하는 것이 더 명확함.

### 이름 기준 파라미터

* 앞에 :를 사용해서 구분.

```java
String usernameParam = "User1";

TypedQuery<Member> query = em.createQuery(
        "SELECT m FROM Member m where m.username = :username", Member.class);
        
query.setParameter("username", usernameParam);
List<Member> resultList = query.getResultList();
```

* 메소드 체인 방식으로 연속 작성 가능.

```java
List<Member> members = em.createQuery(
        "SELECT m FROM Member m where m.username = :username", Member.class)
            .setParameter("username", usernameParam)
            .getResultList();
```

### 위치 기준 파라미터

* ? 다음에 위치 값 지정.

```java
List<Member> members = em.createQuery(
        "SELECT m FROM Member m where m.username = ?1", Member.class)
            .setParameter(1, usernameParam)
            .getResultList();
```

### ※ 파라미터 바인딩 방식은 선택이 아닌 필수

```java
"select m from Member m where m.username = "'" + usernameParam + "'"
```

* 위 처럼 직접 문자를 더해 만들어 넣으면 문제가 발생.
    * SQL 인젝션 공격의 가능성.
    * 성능 이슈.
        * 파라미터 바인딩을 사용하면 파라미터가 달라져도 같은 쿼리로 인식하므로
          JPA는 JPQL을 SQL로 파싱한 결과를 재사용 수 있음.
          
<br/>

# 프로젝션

* SELECT 절에 조회할 대상을 지정하는 것.
* [SELECT {프로젝션 대상} FROM]으로 대상을 선택.
* 대상은 엔티티, 임베디드 타입, 스칼라 타입(숫자, 문자 등 기본 데이터 타입).

### 1. 엔티티 프로젝션

```java
SELECT m FROM Member m
SELECT m.team FROM Member m
```

* 처음은 회원, 두 번쨰는 회원과 연관된 팀을 조회.
    * 둘 다 엔티티를 프로젝션 대상으로 사용.
* 원하는 객체를 바로 조회한 것으로 컬럼을 나열해서 조회하는 SQL과 차이가 있음.

### 2. 임베디드 타입 프로젝션

* JPQL에서 임베디드 타입은 엔티티와 거의 비슷하게 사용.
* 조회의 시작점이 될 수 없는 제약이 존재.

#### - 조회의 시작점으로 사용불가

* Address가 임베디드 타입이라고 할 때, 조회의 시작점으로 사용된 잘못된 쿼리.

```java
String query = "SELECT a FROM Address a";
```

#### - 엔티티를 통해서 임베디드 타입 조회

```java
String query = "SELECT o.address FROM Order o";
List<Address> addresses = em.createQuery(query, Address.class).getResultList();
```

### 3. 스칼라 타입 프로젝션

* 숫자, 문자, 날짜와 같은 기본 데이터 타입들을 스칼라 타입이라고 함.

```java
List<String> usernames = em.createQuery("SELECT username FROM Member m", String.class)
        .getResultList(); // 전체 회원 이름 조회(문자열)
```

#### - 중복 데이터 제거

```java
SELECT DISTINCT username FROM Member m
```

#### - 통계 쿼리

```java
Double orderAmountAvg = em.createQuery("SELECT AVG(o.orderAmount) FROM Order o", Double.class)
        .getResultList();
```

### 4. 여러 값 조회

* 엔티티가 아닌 꼭 필요한 데이터들만 선택해서 조회해야 할 때 사용.

#### - 스칼라 타입만 조회

```java
List<Object[]> resultList = em.createQuery("SELECT m.username, m.age FROM Member m")
    .getResultList();

for (Object[] row : resultList) {
    String username = (String) row[0];
    Integer age (Integer) row[1];
}
```

#### - 엔티티 타입과 스칼라 타입 조회

```java
List<Object[]> resultList = em.createQuery(
        "SELECT o.member, o.product, o.orderAmount FROM Order o").getResultList();

for (Object[] row : resultList) {
    Member member = (Member) row[0]; //엔티티
    Product product = (Product) row[1]; //엔티티
    int orderAmount = (Integer) row[2]; //스칼라
}
```

### 5. NEW 명령어

* 보통 UserDTO처럼 의미 있는 객체를 사용.
* NEW 명령어를 사용해서 조회 데이터를 객체로 변환하는 작업을 생략 가능.

```java
TypedQuery<UserDTO> query = em.createQuery(
        "SELECT new jpabook.jpql.UserDTO(m.username, m.age) FROM Member m", UserDTO.class);
List<UserDTO> resultList = query.getResultList();
```

* 위 처럼 SELECT 다음에 NEW 명령어로 반환받을 클래스를 지정.
* 지정한 클래스의 생성자에 JPQL 조회 결과를 넘겨줄 수 있음.
* 주의 사항
    1. 패키지 명을 포함한 전체 클래스 명을 입력.
    2. 순서와 타입이 일치하는 생성자가 필요.