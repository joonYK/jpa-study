JPA가 제공하는 기능은 크게 `엔티티와 테이블을 매핑`하는 설계 부분, `매핑한 엔티티를 사용`하는 부분으로 나뉜다.   
엔티티 매니저(EntityManager)는 엔티티에 대한 CRUD 조작과 같이 `엔티티와 관련된 모든 일을 처리`하는 엔티티 관리자다. 
개발자 입장에서 엔티티 매니저를 엔티티에 대한 가상의 데이터베이스라고 생각할 수 있다.

## 엔티티 매니저 팩토리와 엔티티 매니저

엔티티 매니저 팩토리는 데이터베이스당 하나이며, META-INF/persistence.xml 에 있는 정보를 바탕으로 생성한다. 그래서 보통 엔티티 매니저 팩토리는 하나만 생성(비용이 큼)하며,
팩토리에서 엔티티 매니저를 여러개 생성(비용이 작음)할 수 있다.  엔티티 매니저 팩토리는 다중 스레드 접근이 안전하지만, 엔티티 매니저는 동시성 문제가 있어서 스레드 간에 공유를 하면 안 된다.

###  엔티티 매니저의 커넥션 풀 회득

엔티티 매니저는 데이터베이스 연결이 꼭 필요한 시점이 오기 전까지는 커넥션을 얻지 않는다. 보통 트랜잭션 시작시에 커넥션을 획득한다.

<br/>

## 영속성 컨텍스트(persistence context)

굳이 우리말로 해석하자면 `엔티티를 영구 저장하는 환경`이라고 할 수 있다. 엔티티를 저장 또는 조회하면 엔티티 매니저가 영속성 컨텍스트에 엔티티를 저장하고 관리한다.
엔티티 매니저의 persist 메서드가 실제로는 영속성 컨텍스트에 데이터를 저장하는 것이다.   
영속성 컨텍스트는 엔티티 매니저를 생성할 때 하나 만들어지고, 엔티티 매니저를 통해 접근 및 관리할 수 있다. 또한 여러 엔티티 매니저가 하나의 영속성 컨텍스트에 접근할 수도 있다.

<br/>

## 엔티티의 생명주기 (엔티티의 4가지 상태)

* 비영속(new/transient) : 영속성 컨텍스트와 전혀 관계 없는 상태
* 영속(managed) : 영속성 컨텍스트에 저장된 상태 (엔티티 매니저를 통해 조회 및 persist 메서드를 통해 저장)
* 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태 (특정 엔티티 detach, 영속성 컨텍스트 닫기 close, 영속성 컨텍스트 초기화 clear)
* 삭제(removed) : 삭제된 상태 (remove 메서드로 영속성 컨텍스트와 데이터베이스에서 삭제)

<br/>

## 영속성 컨텍스트 특징

### 영속성 컨텍스트와 식별자 값

엔티티를 식별자 값("@Id"로 매핑한 기본키 필드)으로 구분. 영속 상태는 식별자 값이 반드시 필요 (없으면 예외).

### 영속성 컨텍스트와 데이터베이스 저장

영속성 컨텍스트에 엔티티를 저장하면 보통 트랜잭션을 커밋하는 순간에 엔티티를 데이터베이스에 반영한다. 이것을 `플러시(flush)`라고 한다.

### 영속성 컨텍스트가 엔티티를 관리할 때 장점

**1. 1차 캐시**

영속성 컨텍스트 내부에는 Map으로 된 저장소를 하나 갖고있는데, 이것을 1차 캐시라고 한다. 이 1차 캐시는 @Id로 매핑한 식별자 값을 key로, 엔티티 인스턴스를 value로 저장한다.
find 메서드로 엔티티를 조회하면 1차 캐시에서 먼저 조회하고 찾는 엔티티가 없을 때 데이터베이스에서 가져온다. 데이터베이스에서 조회하면 1차 캐시에 저장해두고, 이후부터는 메모리에 저장된
1차 캐시에서 조회하기때문에 성능상 장점이 있다.

**2. 영속 엔티티의 동일성 보장**

```java
EntityManager em = ... ;
Member a = em.find (Member.class, "member1");
Member b = em.find (Member.class, "member1");
System.out.println(a == b) //true
```

1차 캐시에서 엔티티를 조회하기 때문에 엔티티의 동일성을 보장한다. 즉, 같은 인스턴스.

**3. 트랜잭션을 지원하는 쓰기 지연**

엔티티를 등록,수정,삭제 시에 엔티티 매니저는 트래잭션을 커밋하기 전까지 내부 쿼리 저장소에 SQL을 모아둔다. 그리고 트랜잭션 커밋시에 데이터베이스에 SQL을 보내는데 이것을 트랜잭션을 지원하는 쓰기 지연이라고 한다 .
모아둔 쿼리를 데이터베이스에 한번에 보내기 때문에 데이터베이스와의 통신횟수를 줄여 성능상의 이점을 얻을 수 있다.

**4. 변경 감지**

엔티티를 수정할 때는 영속화된 엔티티의 데이터를 변경하기만 하면 된다. 그러면 커밋시에 변경사항을 데이터베이스에 자동으로 반영하는데 이 기능을 변경 감지(dirty checking)라고 한다.
JPA는 엔티티를 영속성 컨텍스트에 보관할 떄, 최초 상태를 복사해서 저장(스냅샷)하는데, 플러시 시점(트랜잭션 커밋)에 비교해서 변경된 엔티티를 찾는다. 변경된 엔티티가 있으면 쓰기 지연 SQL 저장소에 UPDATE SQL을 보내서 최종적으로 데이터베이스에 반영한다.

**5. 지연 로딩**

엔티티 내부에서 다른 엔티티(join)를 참조할 때, 실제 사용시점에 데이터베이 조회한다.










