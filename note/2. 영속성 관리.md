JPA가 제공하는 기능은 크게 `엔티티와 테이블을 매핑`하는 설계 부분, `매핑한 엔티티를 사용`하는 부분으로 나뉜다.   
엔티티 매니저(EntityManager)는 엔티티에 대한 CRUD 조작과 같이 `엔티티와 관련된 모든 일을 처리`하는 엔티티 관리자다. 
개발자 입장에서 엔티티 매니저를 엔티티에 대한 가상의 데이터베이스라고 생각할 수 있다.

## 엔티티 매니저 팩토리와 엔티티 매니저

엔티티 매니저 팩토리는 데이터베이스당 하나이며, META-INF/persistence.xml 에 있는 정보를 바탕으로 생성한다. 그래서 보통 엔티티 매니저 팩토리는 하나만 생성(비용이 큼)하며,
팩토리에서 엔티티 매니저를 여러개 생성(비용이 작음)할 수 있다.  엔티티 매니저 팩토리는 다중 스레드 접근이 안전하지만, 엔티티 매니저는 동시성 문제가 있어서 스레드 간에 공유를 하면 안 된다.

###  엔티티 매니저의 커넥션 풀 회득

엔티티 매니저는 데이터베이스 연결이 꼭 필요한 시점이 오기 전까지는 커넥션을 얻지 않는다. 보통 트랜잭션 시작시에 커넥션을 획득한다.

<br/>

## 영속성 컨텍스트(persistence context)

굳이 우리말로 해석하자면 `엔티티를 영구 저장하는 환경`이라고 할 수 있다. 엔티티를 저장 또는 조회하면 엔티티 매니저가 영속성 컨텍스트에 엔티티를 저장하고 관리한다.
엔티티 매니저의 persist 메서드가 실제로는 영속성 컨텍스트에 데이터를 저장하는 것이다.   
영속성 컨텍스트는 엔티티 매니저를 생성할 때 하나 만들어지고, 엔티티 매니저를 통해 접근 및 관리할 수 있다. 또한 여러 엔티티 매니저가 하나의 영속성 컨텍스트에 접근할 수도 있다.

<br/>

## 엔티티의 생명주기 (엔티티의 4가지 상태)

* 비영속(new/transient) : 영속성 컨텍스트와 전혀 관계 없는 상태
* 영속(managed) : 영속성 컨텍스트에 저장된 상태 (엔티티 매니저를 통해 조회 및 persist 메서드를 통해 저장)
* 준영속(detached) : 영속성 컨텍스트에 저장되었다가 분리된 상태 (특정 엔티티 detach, 영속성 컨텍스트 닫기 close, 영속성 컨텍스트 초기화 clear)
* 삭제(removed) : 삭제된 상태 (remove 메서드로 영속성 컨텍스트와 데이터베이스에서 삭제)

<br/>

## 영속성 컨텍스트 특징

### 영속성 컨텍스트와 식별자 값

엔티티를 식별자 값("@Id"로 매핑한 기본키 필드)으로 구분. 영속 상태는 식별자 값이 반드시 필요 (없으면 예외).

### 영속성 컨텍스트와 데이터베이스 저장

영속성 컨텍스트에 엔티티를 저장하면 보통 트랜잭션을 커밋하는 순간에 엔티티를 데이터베이스에 반영한다. 이것을 `플러시(flush)`라고 한다.

### 영속성 컨텍스트가 엔티티를 관리할 때 장점

**1. 1차 캐시**

영속성 컨텍스트 내부에는 Map으로 된 저장소를 하나 갖고있는데, 이것을 1차 캐시라고 한다. 이 1차 캐시는 @Id로 매핑한 식별자 값을 key로, 엔티티 인스턴스를 value로 저장한다.
find 메서드로 엔티티를 조회하면 1차 캐시에서 먼저 조회하고 찾는 엔티티가 없을 때 데이터베이스에서 가져온다. 데이터베이스에서 조회하면 1차 캐시에 저장해두고, 이후부터는 메모리에 저장된
1차 캐시에서 조회하기때문에 성능상 장점이 있다.

**2. 영속 엔티티의 동일성 보장**

```java
EntityManager em = ... ;
Member a = em.find (Member.class, "member1");
Member b = em.find (Member.class, "member1");
System.out.println(a == b) //true
```

1차 캐시에서 엔티티를 조회하기 때문에 엔티티의 동일성을 보장한다. 즉, 같은 인스턴스.

**3. 트랜잭션을 지원하는 쓰기 지연**

엔티티를 등록,수정,삭제 시에 엔티티 매니저는 트래잭션을 커밋하기 전까지 내부 쿼리 저장소에 SQL을 모아둔다. 그리고 트랜잭션 커밋시에 데이터베이스에 SQL을 보내는데 이것을 트랜잭션을 지원하는 쓰기 지연이라고 한다 .
모아둔 쿼리를 데이터베이스에 한번에 보내기 때문에 데이터베이스와의 통신횟수를 줄여 성능상의 이점을 얻을 수 있다.

**4. 변경 감지**

엔티티를 수정할 때는 영속화된 엔티티의 데이터를 변경하기만 하면 된다. 그러면 커밋시에 변경사항을 데이터베이스에 자동으로 반영하는데 이 기능을 변경 감지(dirty checking)라고 한다.
JPA는 엔티티를 영속성 컨텍스트에 보관할 떄, 최초 상태를 복사해서 저장(스냅샷)하는데, 플러시 시점에 비교해서 변경된 엔티티를 찾는다. 변경된 엔티티가 있으면 쓰기 지연 SQL 저장소에 UPDATE SQL을 보내서 최종적으로 데이터베이스에 반영한다.

**5. 지연 로딩**

실제 객체 대신 프록시 객체를 로딩해두고 해당 객체를 실제 사용시에 영속성 컨텍스트를 통해 데이터를 조회하는 방법이다.

<br/>

## 플러시

플러시(flush)는 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다.

### 동작 순서

1. 변경 감지로 엔티티들의 스냅샷과 현재를 비교해서 수정된 엔티티를 찾는다.
2. 수정된 엔티티는 쿼리를 만들어서 쓰기 지연 SQL 저장소에 등록한다.
3. 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스로 전송한다. (등록, 수정, 삭제 쿼리)

### 플러시를 하는 방법
  
1. 엔티티 매니저의 flush() 직접 호출.
   
    영속성 컨텍스트를 강제로 플러시할 수 있지만, 테스트나 다른 프레임워크와 JPA를 함께 사용할 떄를 제외하고 거의 사용 안 함.


2. 트랜잭션 커밋 시 자동 호출.
    
    트랜잭션을 커밋 하더라도 변경 내용에 대한 SQL을 미리 데이터베이스에 전달하지 않으면 변경 내용이 반영되지 않는다. 그래서 커밋전에는 항상 플러시 작업이 필수이다.

   
3. JPQL 쿼리 실행 시 자동 호출.

```java
em.persist(memberA);
em.persist(memberB);
em.persist(memberC);

query = em.createQuery("select m from Member m", Member.class);
List<Member> members = query.getResultList();
```

먼저 persist로 엔티티 3개를 영속 상태로 만들었다. 하지만 데이터베이스에는 반영 되지 않은 상태이기 때문에 이 상태로 JPQL을 사용해서 조회해봤자 조회된 데이터가 없을것이다.
그래서 쿼리 실행 직전에 플러시를 해서 변경 내용을 데이터베이스에 반영해야 한다.

참고로 특정 엔티티에 대해 식별자로 조회하는 find 메서드는 플러스기 실행되지 않는다.

### 플러시 모드 옵션

엔티티 매니저의 플러시 모드를 직접 지정하려면 javax.persistence.FlushModeType을 사용한다.

* FlushModeType.AUTO : 커밋이나 쿼리 실행 시 플러시 (기본값)
* FlushModeType.COMMIT : 커밋할 때만 플러시

보통은 기본값인 AUTO를 사용한다. COMMIT 모드는 성능 최적화가 필요할 때 사용.

<br/>

## 준영속

영속 상태의 엔티티를 영속성 컨텍스트에서 제거해서 영속성 컨텍스트가 제공하는 기능을 사용할 수 없는 상태.
준영속 상태가 된 엔티티의 모든 정보(1차 캐시 및 SQL 쓰기 지연에 저장된 쿼리 등)를 영속성 컨텍스트에서 제거한다.

1. em.detach(entity) : 특정 엔티티만 준영속 상태로 전환.
2. em.clear() : 모든 엔티티를 준영속 상태로 전환.
3. em.close() : 영속성 컨텍스트를 종료. (영속성 컨텍스트 자체가 없음)

### 준영속 상태의 특징

* 거의 비영속 상태에 가까움

   영속성 컨텍스트가 제공하는 어떠한 기능도 동작하지 않게 된다.


* 식별자 값 존재

   비영속 상태는 식별자 값이 없을수도 있지만, 준영속 상태는 한번 영속 상태였기 때문에 식별자 값을 가지고 있다.


* 지연 로딩 불가

   지연 로딩시 문제가 발생.



