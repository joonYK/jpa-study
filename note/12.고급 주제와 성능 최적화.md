# 예외 처리

* JPA를 사용할 떄 발생하는 다양한 예외와 예외에 따른 주의점들.

## JPA 표준 예외

* javax.persistence.PersistenceException의 자식 클래스.
  * 모든 JPA 예외는 javax.persistence 패키지에 있음. 
  * RuntimeException의 자식. (모두 언체크 예외)
* 트랜잭션 롤백을 표시하는 예외와 표시하지 않는 예외 2가지로 나뉨.
  * 롤백을 표시하는 예외는 심각한 예외로 복구하면 안 됨.
    * 트랜잭션을 강제로 커밋해도 RollbackException 예외 발생.
  * 롤백을 표시하지 않는 예외는 심각한 예외가 아니므로 개발자가 커밋 또는 롤백할지 판단.

### 트랜잭션 롤백을 표시하는 예외

|예외|설명|
|---|---|
|EntityExistsException|EntityManager.persist()호출 시 이미 같은 엔티티가 있으면 발생.|
|EntityNotFoundException|EntityManager.getReference()를 호출했지만 실제 사용 시 엔티티가 존재하지 않으면 발생.<br/>refresh(), lock()에서도 발생.|
|OptimisticLockException|낙관적 락 충돌 시 발생.|
|PessimisticLockException|비관적 락 충돌 시 발생.|
|RollbackException|EntityTransaction.commit() 실패 시 발생.<br/>롤백이 표시되어 있는 트랜잭션 커밋 시에도 발생.|
|TransactionRequiredException|트랜잭션이 필요할 때 트랜잭션이 없으면 발생.<br/>트랜잭션이 없이 엔티티를 변경할 때 주로 발생.|

### 트랜잭션 롤백을 표시하지 않는 예외

|예외|설명|
|---|---|
|NoResultException|Query.getSingleResult() 호출 시 결과가 하나도 없을 때 발생.|
|NonUniqueResultException|Query.getSingleResult() 호출 시 결과가 둘 이상일 때 발생.|
|LockTimeoutException|비관적 락에서 시간 초과 시 발생.|
|QueryTimeoutException|쿼리 실행 시간 초과 시 발생.|

## 스프링 프레임워크의 JPA 예외 변환

* 서비스 계층에서 JPA의 예외를 직접 사용하면 JPA에 의존하게 됨.
* 스프링 프레임워크는 이런 문제 해결을 위해 데이터 접근 계층에 대한 예외를 추상화 함.

### JPA 예외를 스프링 예외로 변경

|JPA 예외|스프링 변환 예외|
|---|---|
|PersistenceException|org.springframework.orm.jpa.JpaSystemException|
|NoResultException|org.springframework.dao.EmptyResultDataAccessException|
|NonUniqueResultException|org.springframework.dao.IncorrectResultSizeDataAccessException|
|LockTimeoutException|org.springframework.dao.CannotAcquireLockException|
|QueryTimeoutException|org.springframework.dao.QueryTimeoutException|
|EntityExistsException|org.springframework.dao.DataIntegrityViolationException|
|EntityNotFoundException|org.springframework.orm.jpa.JpaObjectRetrievalFailureException|
|OptimisticLockException|org.springframework.org.jpa.JpaOptimisticLockingFailureException|
|PessimisticLockException|org.springframework.dao.PessimisticLockingFailureException|
|TransactionRequiredException|org.springframework.dao.InvalidDataAccessApiUsageException|
|RollbackException|org.springframework.transaction.TransactionSystemException|

## 스프링 프레임워크에 JPA 예외 변환기 적용

* JPA 예외를 스프링 프레임워크의 추상화 예외로 변경하려면 특정 객체를 스프링 빈으로 등록.
  * PersistenceExceptionTranslationPostProcessor
* @Repository를 사용한 곳에 예외 변환 AOP를 적용해서 변환.
* 예외를 변환하고 싶지 않으면 메서드에 thorws로 JPA 예외나 JPA 예외의 부모 클래스를 직접 명시.

## 트랜백션 롤백 시 주의사항

* 트랜잭션 롤백은 DB만 롤백하고 수정한 자바 객체까지 원상태로 복구하지 않음.
  * 즉, 엔티티가 수정된 상태로 영속성 컨텍스트에 남아 있게 됨.
* 새로운 영속성 컨텍스트를 사용하거나 EntityManager.clear()로 초기화한 다음 사용해야 함.

### 스프링 프레임워크의 예방방법

* 영속성 컨텍스트의 범위에 따라 다른 방법을 사용.

#### 1. 기본 전략 (트랜잭션당 영속성 컨텍스트)

* 문제가 발생하면 트랜잭션 AOP 종료 시점에 트랜잭션을 롤백하면서 영속성 컨텍스트도 함께 종료.

#### 2. OSIV (영속성 컨텍스트의 범위를 트랜잭션 범위보다 넓게 사용)

* 영속성 컨텍스트에 문제가 있어도 다른 트랜잭션에서 해당 영속성 컨텍스트를 그대로 사용하는 문제가 있음.
* 롤백시 영속성 컨텍스트를 초기화.

<br/>

# 엔티티 비교

* 영속성 컨텍스트가 같을때와 다를 때의 비교 방법을 다르게 해야 함.

## 영속성 컨텍스트가 같을 때

* 특정 엔티티를 조회하는 코드가 여러 곳에 있어도, 영속성 컨텍스트 범위가 같다면 같은 인스턴스의 엔티티를 조회.
  * 예를 들어, 테스트 클래스에 @Transactional을 선언하고 테스트.
  * 해당 테스트 메서드에서 실행될 서비스 로직들은 전부 같은 영속성 컨텍스트를 바라봄.
* 동일성(==), 동등성(equals), 데이터베이스 동등성(@Id)로 모두 비교 가능.

#### ※ 테스트 클래스에 @Transactional 적용

* 테스트가 끝날 때 트랜잭션을 커밋하지 않고 강제로 롤백.
* DB에 영향을 주지 않고 테스트를 반복해서 수행 가능.
* 롤백시 영속성 컨텍스트를 플러시하지 않는데, SQL을 콘솔 로그에서 볼 수가 없음.
  * 어떤 SQL이 실행되는지 확인하려면 em.flush()를 강제로 호출.

## 영속성 컨텍스트가 다를 때 엔티티 비교

* 예를 들어 테스트 클래스에 @Transactionl이 없고 서비스에 있으면 각 서비스별로 영속성 컨텍스트 범위를 가짐.
* 테스트 메서드에서 여러 서비스에 동일한 엔티티를 조회해오면, 각각의 엔티티는 전혀 다른 인스턴스가 된다.
  * 각 엔티티는 영속성 컨텍스트가 종료되어 준영속 상태가 된 엔티티들.
* 동일성(==) 비교는 실패. 
* 데이터베이스 동등성(@Id) 비교 가능.
  * 엔티티를 영속화해야 식별자를 얻을 수 있는 문제 있음. (영속화 전엔 null이라 비교 불가)
* 동등성(equals) 비교 가능. (권장)
  * equals를 오버라이딩해서 비즈니스 키가 되는 필드를 이용해 비교.
  * 주민등록번호나 회원이름과 연락처 등등.

<br/>

# 프록시 심화 주제

* 프록시는 원본 엔티티를 상속받으므로 클라이언트는 프록시인지 원봉인지 구분않고 사용.
* 원본 엔티티를 사용하다가 지연 로딩을 위해 프록시로 변경해도 클라이언트의 로직 수정 필요 없음.
* 프록시를 사용하는 방식의 기술적 한계로 문제들이 발생하기도 함.

## 영속성 컨텍스트와 프록시 (프록시 동일성 비교)

```java
//프록시로 조회
Member refMember = em.getReference(Member.class, "member1");
//원본 엔티티를 조회
Member findMember = em.find(Member.class, "member1");
//같음
Assert.assertTrue(refMember == findMember);
```

* 영속성 컨텍스트는 프록시로 조회된 엔티티에 대해 같은 엔티티 조회 요청이 오면 처음 조회된 프록시를 반환.
* 반대로 원본 데이터를 먼저 조회하면 프록시를 조회해도 원본 데이터를 반환함.
* 영속 엔티티의 동일성을 보장.

## 프록시 타입 비교

* 프록시로 조회한 엔티티의 타입을 비교할 땐 instanceof를 사용.
* 프로시의 타입은 끝에 _$$_jvsteXXX가 붙음.
  * jy.study.jpa.Member_$$_jvste843_0

```java
Member refMember = em.getReference(Member.class, "member1");
//부모 클래스와 자식 클래스를 비교한 것이 됨.
Assert.assertFalse(Member.class == refMember.getClass());
//프록시는 원본 엔티티의 자식 타입이므로 성립.
Assert.assertTrue(refMember instanceof Member);
```

## 프록시 동등성 비교

* 비즈니스 키를 이용해 equals() 메소드를 오버라이딩하고 비교.
* IDE나 외부 라이브러리를 사용해 equals()를 구현해서 프록시와 비교시 문제 발생.

```java
//equals 오버라이딩
public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null) return false;
    
    //프록시와 비교시 문제되는 코드 1
    if (this.getClass() != obj.getClass()) return false;
    
    Member member = (Member) obj;
    
    //프록시와 비교시 문제되는 코드 2
    if(name != null ? !name.equals(member.name) : member.name != null)
        return false;
    
    return true;
}

//테스트
Member newMember = new Member("member1", "회원1");
Member refMember = em.getReference(Member.class, "member1");
Assert.assertTrue(newMember.equals(refMember)); // 테스트 실패
```

* 위 문제코드1 
  * 동일성을 비교하고 있는데, 프록시와의 비교에선 instanceof를 사용해서 비교 필요.
  * if(!(obj instanceof Member)) return false;
* 위 문제코드2 
  * Member.name으로 프록시의 멤버변수에 직접 접근하는데, 프록시는 실제 데이터가 없고 null로 아무 값도 조회할 수 없음.
  * 프록시의 데이터를 조회할 땐 getter 접근자를 사용해서 프록시가 원본 엔티티의 데이터를 가져오도록 해야함.
  * if(name != null ? !name.equals(member.getName()) : member.getName() != null)

## 상속관계과 프록시

### 프록시 부모 타입으로 조회시 발생하는 문제

* Item을 각각 상속하는 Book, Movie, Album이 있음.
* Item을 멤버필드로 갖는 OrderItem이 있음.

```java
Book saveBook = new Book();
saveBook.setName("jpaBook");
saveBook.setAuthor("kim");
em.persist(saveBook); 
em.flush(); 
em.clear();

//POINT 1 Item 엔티티를 프록시로 조회
Item proxyItem = em.getReference(Item.class, saveBook.getId());
//POINT 2 출력결과 : proxyItem = class xxx.xxx...xxx.Item_$$_jvstXXX
System.out.println("proxyItem = " + proxyItem.getClass());

//POINT 3 proxyItem이 Book의 클래스 타입인지 확인.
if (proxyItem instanceof Book) {
    //POINT 4 다운캐스팅
    Book book = (Book) proxyItem;
    System.out.println("proxyItem = " + proxyItem.getClass());
}

Assert.assertFalse(proxyItem.getClass() == Book.class)
Assert.assertFalse(proxyItem instanceof Book);
Assert.assertTrue(proxyItem instanceof Item);
```

* POINT 3은 if문을 통과하지 못하고 실패.
* POINT 1에서 프록시가 Item 타입을 기반으로 만들어졌으며 프록시가 참조하는 엔티티는 Book 엔티티.
* POINT 2의 출력결과의 타입이 Item 타입을 상속해 만들어진 타입을 출력.
* 위의 이유들로 proxyItem은 Item$Proxy 타입이고 Book 타입과는 관계가 없음.
* POINT 4에서 proxyItem은 Book 타입과 관련이 없기때문에 다운캐스팅 에러 발생.

#### 다형성을 다루는 도메인 모델에서 문제 자주 발생

```java
@Entity
public class OrderItem {
  ...
  @manyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = "ITEM_ID")
  private Item item;
}

//테스트
OrderItem saveOrderItem = new OrderItem();
saveOrderItem.setItem(book);
em.persist(saveOrderItem); 
em.flush(); 
em.clear();

OrderItem orderItem = em.find(OrderItem.class, saveOrderItem.getId());
Item item = orderItem.getItem();

Assert.assertFalse(proxyItem.getClass() == Book.class);
```

* OrderItem과 item의 관계처럼 다형성 관계에서 지연로딩 시에 문제가 발생함.

## 상속관계에서 발생하는 프록시 문제 해결 방법

### 1. JPQL로 대상 직접 조회

* 가장 간단한 방법으로 처음부터 자식 타입을 직접 조회해서 필요한 연산 수행.
* 이 방법은 다형성을 활용할 수 없는 단점이 있음.

```java
Book jpqlBook = em.createQuery("select b from Book where b.id=:bookId", Book.class)
        .setParameter("bookId", item.getId())
        .getSingleResult();
```

### 2. 프록시 벗기기

* 하이버네이트가 제공하는 기능을 사용하면 프록시에서 원본 엔티티 조회 가능.

```java
public static <T> T unProxy(Object entity) {
    if (entity instanceof HibernateProxy) {
        entity = ((HibernateProxy) entity) 
                      .getHibernateLazyInitializer()
                      .getImplementation();
    }
    return (T) entity;
}

...
Item item = orderItem.getItem();
Item unProxyItem = unProxy(item);
...
```

* 프록시에서 원본 엔티티를 직접 꺼내기 때문에 프록시와 원본 엔티티의 동일성 비교가 실패하는 문제점 있음.
  * 위의 코드에서 item과 unProxyItem의 동일성 비교는 false가 됨.
* 원본 엔티티가 꼭 필요한 곳에서 잠깐 사용하고 다른 곳에서 사용되지 않도록 하는 것이 중요.
* 원본 엔티티의 값 변경시 변경 감지 기능 동작함.