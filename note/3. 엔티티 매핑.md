JPA는 엔티티와 테이블을 정확히 매핑하는것이 가장 중요. 매핑 방법은 xml과 어노테이션 중에서 일반적으로 어노테이션 방식을 많이 사용. 

* 대표 어노테이션
    * 객체와 테이블 매핑 : @Entity, @Table
    * 기본 키 매핑 : @Id
    * 필드와 컬럼 매핑 : @Column
    * 연관관계 매핑 : @ManyToOne, @JoinColumn
    
## @Entity

테이블과 매핑할 클래스는 @Entitiy 어노테이션을 필수로 적용, JPA가 관리하는 클래스로 엔티티라고 한다.
name 속성값을 줘서 엔티티 이름을 지정할 수 있고, 생략하면 클래스 이름을 사용.
    
### 주의사항

* 기본 생성자는 필수.
* final 클래스, enum, interface, inner 클래스는 사용 불가.
* 저장할 필드에 final 사용 불가.

<br/>

## @Table

엔티티와 매핑할 테이블을 지정.

* 속성
    * name : 매핑할 테이블 이름. 생략하면 엔티티 이름을 사용.
    * catalog : catalog 기능이 있는 DB에서 catalog 매핑.
    * schema : schema 기능이 있는 DB에서 schema를 매핑.
    * uniqueConstraints : DDL 생설 시에 유니크 제약조건을 만듦. 스미카 자동 생성 기능을 사용해서 DDL을 만들 때만 사용.
  
## 데이터베이스 스키마 자동 생성

persistence.xml에 아래 설정을 추가하면 애플리케이션 실행 시점에 테이블을 자동으로 생성한다.

```xml
<!-- 스키마 자동 생성 기능 -->
<property name="hibernate.hbm2ddl.auto" value="create"/>
<!-- 하이버네이트가 실행한 SQL을 출력 -->
<property name="hibernate.show_sql" value="true"/>
```

자동 생성 기능은 데이터베이스 방언에 따라 필드 타입을 알맞게 생성한다. 예를 들어, H2는 varchar 타입을 오라클은 varchar2 타입으로 생성한다.

* 속성
  * create : 기존 테이블을 삭제하고 새로 생성.
  * create-drop : 애플리케이션 종료할 때 생성한 DLL을 제거.
  * update : 테이블과 엔티티 매핑정보를 비교해서 변경 사항만 수정.
  * validate : 테이블과 엔티티 매핑정보를 비교해서 차이 없으면 경고를 남기고 애플리케이션 실행 안 함.
  * none : 자동 생성 기능을 사용하지 않음.

### 참고사항

* 자동 생성 기능은 편리하지만 운영 환경에서 사용할만큼 완벽하지 않기 때문에 개발 환경에서만 사용하는것이 좋다.
* JPA 2.1부터는 스키마 자동 생성 기능을 표준으로 지원하지만, 하이버네이트의 update, validate는 지원하지 않는다.
  
* DB는 관례상 필드 이름에 언더스코어(예를 들어 role_type)를 주로 사용한다. 그래서 컬럼 매핑이 name 속성으로 직접 명시해야하지만,
hibernate.ejb.naming_strategy 속성을 사용하면 이름 매핑 전략을 변경할 수 있다.
```xml
<!-- 필드 이름 언더스코어 표기법 사용 -->
<property name="hibernate.ejb.naming_strategy" value="org.hibernate.cfg.ImprovedNamingStrategy"/>
```
