JPA는 엔티티와 테이블을 정확히 매핑하는것이 가장 중요. 매핑 방법은 xml과 어노테이션 중에서 일반적으로 어노테이션 방식을 많이 사용. 

* 대표 어노테이션
    * 객체와 테이블 매핑 : @Entity, @Table
    * 기본 키 매핑 : @Id
    * 필드와 컬럼 매핑 : @Column
    * 연관관계 매핑 : @ManyToOne, @JoinColumn
    
## @Entity

테이블과 매핑할 클래스는 @Entitiy 어노테이션을 필수로 적용, JPA가 관리하는 클래스로 엔티티라고 한다.
name 속성값을 줘서 엔티티 이름을 지정할 수 있고, 생략하면 클래스 이름을 사용.
    
### 주의사항

* 기본 생성자는 필수.
* final 클래스, enum, interface, inner 클래스는 사용 불가.
* 저장할 필드에 final 사용 불가.

---

## @Table

엔티티와 매핑할 테이블을 지정.

* 속성
    * name : 매핑할 테이블 이름. 생략하면 엔티티 이름을 사용.
    * catalog : catalog 기능이 있는 DB에서 catalog 매핑.
    * schema : schema 기능이 있는 DB에서 schema를 매핑.
    * uniqueConstraints : DDL 생설 시에 유니크 제약조건을 만듦. 스미카 자동 생성 기능을 사용해서 DDL을 만들 때만 사용.
  
## 데이터베이스 스키마 자동 생성

persistence.xml에 아래 설정을 추가하면 애플리케이션 실행 시점에 테이블을 자동으로 생성한다.

```xml
<!-- 스키마 자동 생성 기능 -->
<property name="hibernate.hbm2ddl.auto" value="create" />
<!-- 하이버네이트가 실행한 SQL을 출력 -->
<property name="hibernate.show_sql" value="true" />
```

자동 생성 기능은 데이터베이스 방언에 따라 필드 타입을 알맞게 생성한다. 예를 들어, H2는 varchar 타입을 오라클은 varchar2 타입으로 생성한다.

* 속성
  * create : 기존 테이블을 삭제하고 새로 생성.
  * create-drop : 애플리케이션 종료할 때 생성한 DLL을 제거.
  * update : 테이블과 엔티티 매핑정보를 비교해서 변경 사항만 수정.
  * validate : 테이블과 엔티티 매핑정보를 비교해서 차이 없으면 경고를 남기고 애플리케이션 실행 안 함.
  * none : 자동 생성 기능을 사용하지 않음.

### 참고사항

* 자동 생성 기능은 편리하지만 운영 환경에서 사용할만큼 완벽하지 않기 때문에 개발 환경에서만 사용하는것이 좋다.
* JPA 2.1부터는 스키마 자동 생성 기능을 표준으로 지원하지만, 하이버네이트의 update, validate는 지원하지 않는다.

---

## DDL 생성 기능

DDL 생성 시에 다양한 제약조건을 추가할 수 있다. 

* 필드에 제약 조건 추가.
```java
    // 회원 이름은 필수로 입력, 10자를 초과하면 안 됨.
    @Column(name = "NAME", nullable = false, length = 10)
    private String username;
```

* 테이블 유니크 제약조건
```java
@Table(name = "MEMBER", uniqueConstraints = {@UniqueConstraint(
    name = "NAME_AGE_UNIQUE",
    columnNames = {"NAME", "AGE"})
})
```

이외에도 여러 제약조건이 있다. 
제약조건은 DDL을 자동 생성할 때만 사용되기 때문에 직접 DDL을 만든다면 사용할 이유가 없지만, 
개발자가 엔티티만 보고 쉽게 제약조건을 파악할 수 있는 장점이 있다.

---

## 기본 키 매핑

기본 키는 `@Id` 어노테이션으로 매핑한다. 기본키는 MySQL의 AUTO_INCREMENT 기능처럼 자동 할당하는 방법이 있다.<br/>

### JPA가 제공하는 기본 키 생성 전략

@GeneratedValue 어노테이션으로 설정하며, 데이터베이스 벤더마다 지원하는 방식이 다르기때문에 아래와 같은 다양한 전략을 사용한다.

* 직접 할당 : 기본 키를 애플리케이션에서 직접 할당.
* 자동 생성 : 대리 키 사용 방식.
  * IDENTITY : 데이터베이스에 위임. (MySQL의 AUTO_INCREMENT)
  * SEQUENCE : 데이터베이스의 시퀀스를 이용해서 할당. (오라클의 시퀀스)
  * TABLE : 키 생성 테이블을 사용. (키 생성용 테이블을 하나 만들어두고 마치 시퀀스처럼 사용)

참고로 키 생성 전략을 위해 persistence.xml에 아래와 같은 설정 추가 필요.

```xml
<property name="hibernate.id.new_generator_mappings" value="true"/>
```

*  적용 가능한 자바 타입
    * 기본 자바형
    * 자바 래퍼형
    * String
    * java.util.Date
    * Java.sql.Date
    * java.math.BigDecimal
    * Java.math.BigInteger

<br/>

### IDENTITY 전략

기본 키 생성 전략을 데이터베이스에 위임하는 전략으로 MySQL, PostgreSQL, SQL Server, DB2에서 주로 사용한다.
그리고 이 전략은 데이터베이스에 값을 저장하고 나서야 기본 키 값을 구할 수 있을 때 사용한다.

* IDENTITY 전략 및 최적화

데이터베이스에 INSERT 한 후에 기본 키 값을 조회할 수 있어서, 하이버네이트는 JDBC3에 추가된 Statement.getGeneratedKeys()를 사용해서 저장과 동시에 생성된
기본 키 값을 얻어올 수 있도록 할 수 있다. 즉, 데이터베이스와 한 번만 통신하도록 한다.

* 주의사항

엔티티의 영속 상태는 식별자가 반드시 필요하지만, IDENTITY 전략은 DB에 저장해야 기본 키를 구할수 있으므로 em.persist()를 호출하는 즉시 바로 등록 쿼리가 실행된다.
즉, 쓰기 지연 동작이 지원되지 않는다.

<br/>

### SEQUENCE 전략

유일한 값을 순서대로 생성하는 DB의 특별한 오브젝트를 활용하는 전략. 오라클, PostgreSQL, DB2, H2에서 주로 사용한다.<br/>
SEQUENCE 전략은 em.persist()를 호출하면 시퀀스를 먼저 조회해서 엔티티에 할당한 후 영속성 컨텍스트에 저장한다. 이후 플러시가 일어나면 데이터베이스에 저장하는 구조로
IDENTITY와 반대되는 동작 구조를 가진다.

#### @SequenceGenerator

시퀀스를 매핑하기 위해 시퀀스 생성기를 등록하고 기본키 매핑에 시퀀스 생성기를 매핑한다.

```java
@Entity
@SequenceGenerator(
        name = "BOARD_SEQ_GENERATOR", //시퀀스 생성기 이름 (필수 입력)
        sequenceName = "BOARD_SEQ", //데이터베이스에 등록되어 있는 시퀀스 이름 (기본값 hibernate_sequence)
        initialValue = 1, //DDL 생성 시에만 사용. 시퀀스 생성 시 처음 시작하는 수 지정. (기본값 1) 
        allocationSize = 1 // 시퀀스 한 번 호출에 증가하는 수 (기본값 50)
        // catalog, schema : 데이터베이스 catalog, schema 이름
)
public class Board2 {

    @Id
    @GeneratedValue(strategy = GenerationType.SEQUENCE, 
                    generator = "BOARD_SEQ_GENERATOR") // 시퀀스 생성기 매핑
    //@SequenceGenerator 어노테이션은 여기에 위치해도 된다.
    private Long id;
}
```

* 주의사항 

SequenceGenerator.allocationSize의 기본값이 50인데, 이는 최적화를 위한 것이다. 영속성 컨텍스트에 저장하기위해 다음 시퀀스값을 데이터베이스에서 조회하는데
JPA는 시퀀스에 접근하는 횟수를 줄이기 위해 한 번에 50을 증가시킨 다음에 1~50까지는 메모리를 통해서 식별자를 할당한다. <br/>
하지만 한 번에 시퀀스 값이 많이 증가하는 부담이 있다면 allocationSize를 1로 설정하면 된다. 이 방법은 hibernate.id.new_generator_mappings 속성을 활성화 시켜야한다.

<br/>

### TABLE 전략

키 생성 전용 테이블을 만들어서 시퀀스를 흉내내는 전략. 시퀀스처럼 테이블 키 생성기를 등록해야한다.

```java
@Getter
@Entity
@TableGenerator(
        name = "BOARD_SEQ_GENERATOR", // 테이블 키 생성기 이름
        table = "MY_SEQUENCES", // 테이블 이름
        pkColumnValue = "BOARD_SEQ", // 컬럼 이름
        allocationSize = 1 // 증가값
)
public class TableSt {

    @Id
    @GeneratedValue(strategy = GenerationType.TABLE, generator = "BOARD_SEQ_GENERATOR")
    private Long id;
}

```

DDL 자동 생성 기능을 사용하면 아래와같은 테이블이 만들어지고 여기에서 테이블별로 키 값을 생성한다.

create table MY_SEQUENCES (  
&nbsp;&nbsp;&nbsp;&nbsp; sequence_name varchar(255) not null,  
&nbsp;&nbsp;&nbsp;&nbsp; next_val bigint,  
&nbsp;&nbsp;&nbsp;&nbsp; primary key (sequence_name)  
)

#### @TableGenerator 속성 정리

* name : 키 생성기 이름 (필수 입력)
* table : 키 생성 테이블 이름 (기본값 hibernate_sequences)
* pkColumnName : 시퀀스 컬럼명 (기본값 sequence_name)
* valueColumnName : 시퀀스 값 컬럼명 (기본값 next_val)
* pkColumnValue : 키로 사용할 값 이름 (기본값 엔티티 이름) 
* initialValue : 초기 값. 마지막으로 생성된 값이 기준 (기본값 0)
* allocationSize : 시퀀스 한 번 호출에 증가하는 수 (기본값 50)
* catalog, schema : 데이터베이스 catalog, schema 이름
* uniqueConstraints(DDL) : 유니크 제약 조건을 지정

table, pkColumnName, valueColumnName의 기본값은 JPA의 각 구현체가 정의한다.

#### TABLE 전략의 최적화

TABLE 전략은 테이블에서 키를 조회하고 다음 값을 증가시키기 위해 수정하기 때문에 SEQUENCE에 비해 한 번더 DB와 통신해야 하는 단점이 있다.
그래서 SEQUENC 전략처럼 allocationSize를 사용해서 같은 방법으로 최적화를 진행한다.

---

## AUTO 전략

AUTO는 선택한 데이터베이스 방언에 따라서 자동으로 전략을 선택한다. 예를 들어 오라클은 SEQUENCE, MySQL은 IDENTITY를 사용한다.
@GeneratedValue.strategy의 기본값은 AUTO이기 때문에, strategy를 빈값으로 두면 AUTO를 사용한다.<br/>

* AUTO의 장점

AUTO는 DB를 변경해도 코드를 수정할 필요가 없는 장점이 있어서 특히 키 생성 전략이 아직 확정되지 않은 개발 초기단계에 사용하기 좋다.

* 주의사항

SEQUENCE나 TABLE 전략이 선택되면 미리 시퀀스나 키 생성 테이블을 만들어 두어야하고, DDL 자동 생성 기능을 사용한다면 자동으로 하이버네이트가 만들어 줄 것이다.
  
