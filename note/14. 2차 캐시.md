# 1차 캐시와 2차 캐시

* 네트워크를 통한 DB 접근하는 것보다 내부 메모리에 접근하는 시간 비용이 수만 ~ 수십만 배 저렴.
* 조회한 데이터를 메모리에 캐시해서 DB 접근 횟수를 줄여 애플리케이션 성능 획기적으로 개선 가능.
* 1차 캐시는 영속성 컨텍스트 내부의 보관소에 저장.
* 2차 캐시는 애플리케이션 범위의 캐시를 지원하며 공유 캐시라고도 함.

## 1차 캐시

* 영속성 컨텍스트 내부에 존재.
  * 엔티티 매니저로 조회, 변경하는 모든 엔티티 저장됨.
  * 트랜잭션 커밋하거나 플러시 호출시 엔티티 변경 내역 DB에 동기화.
* JPA를 J2EE나 스프링 같은 컨테이너 위에서 실행시 트랜잭션 시작부터 종료시까지 1차 캐시 유효.
* OSIV 사용시 요청의 시작부터 끝날 때까지만 1차 캐시 유효.
* 애플리케이션 전체로 봤을때 DB 접근 횟수를 획기적으로 줄이지는 못함.

### 1차 캐시 동작 방식

1. 최초 조회시에 1차 캐시에 엔티티가 없음.
2. DB에서 엔티티를 조회.
3. 조회한 엔티티 1차 캐시에 보관.
4. 1차 캐시에 보관한 결과를 반환.
5. 같은 엔티티 조회시 1차 캐시에 있으면 1차 캐시의 엔티티를 반환.

### 1차 캐시 특징.

* 같은 엔티티가 있으면 해당 엔티티를 그대로 반환하므로 객체 동일성 (a == b)을 보장.
* 기본적으로 영속성 컨텍스트 범위의 캐시.

## 2차 캐시

* 애플리케이션이 공유하는 캐시로 JPA는 공유 캐시라 하며, 일반적으로 2차 캐시라 부름.
* 애플리케이션 범위의 캐시로 애플리케이션 종료시까지 캐시가 유지.
* 분산 캐시나 클러스터링 환경의 캐시는 애플리케이션보다 더 오래 유지 가능.
* 1차 캐시 -> 2차 캐시 -> DB 순으로 조회해서 DB 접근 횟수 획기적으로 줄일 수 있음.

### 2차 캐시 동작 방식

1. 영속성 컨텍스트에 엔티티가 필요하면 2차 캐시 조회.
2. 2차 캐시에 엔티티 없으면 DB 조회.
3. 결과를 2차 캐시에 보관.
4. 2차 캐시는 보관중인 엔티티 복사해서 반환.
5. 2차 캐시에 저장되어 있는 엔티티를 조회하면 복사본을 만들어 반환.

## 2차 캐시 특징

* 영속성 유닛 범위의 캐시.
* 동시성 극대화를 위해 복사본을 만들어서 반환.
  * 그대로 반환하면 여러 곳에서 같은 객체를 동시에 수정하는 문제 발생. 
* DB 기본 키를 기준으로 캐시하지만 영속성 컨텍스트가 다르면 동일성(a == b) 보장하지 않음.

<br/>

# JPA 2차 캐시 기능

* JPA 캐시 표준은 여러 구현체가 공통으로 사용하는 부분만 표준화.
* 세밀한 설정은 구현체에 의존.

## 캐시 모드 설정

### step 1. @Cacheable

* 2차 캐시 사용은 엔티티에 javax.persistence.Cacheable 어노테이션 사용.
* 설정은 true/false 가 있으며 기본값은 true.

```java
@Cacheable
@Entity 
public class Member {
    ...
}
```

### step 2. shard-cache-mode

* persistence.xml에 shard-cache-mode를 설정.
* 애플리케이션 전체(영속성 유닛 단위) 캐시를 어떻게 적용할지 옵션을 설정.

```xml
<persistence-unit name="test">
    <shard-cache-mode>ENABLE_SELECTIVE</shard-cache-mode>
</persistence-unit>
```

#### 스프링 프레임워크를 사용할 때 설정

```xml
<bean id="entityManagerFactory" class="org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean">
    <property name="sharedCacheMode" value="ENABLE_SELECTIVE"/>
</bean>
```

#### SharedCacheMode 캐시 모드

|캐시 모드|설명|
|---|---|
|ALL|모든 엔티티를 캐시.|
|NONE|캐시 사용 안 함.|
|ENABLE_SELECTIVE|Cacheable(true)로 설정된 엔티티만 캐시 적용.<br/>보통 이 모드를 사용.|
|DISABLE_SELECTIVE|모든 엔티티를 캐시하지만 Cacheable(false)로 명시된 엔티티 캐시 안 함.|
|UNSPECIFIED|JPA 구현체가 정의한 설정 따름.|

## 캐시 조회, 저장 방식 결정

* 캐시 무시하고 DB를 직접 조회시 캐시 조회 모드 설정.
* 캐시를 갱신시 캐시 보관 모드 설정.

### 캐시 조회 모드 사용시 옵션

* javax.persistence.cache.retrieveMode : 프로퍼티 이름
* javax.persistence.CacheRetrieveMode : 설정 옵션
  * USE : 캐시에서 조회, 기본값.
  * BYPASS : 캐시를 무시하고 DB에 직접 접근.
  
### 캐시 보관 모드 사용시 옵션

* javax.persistence.cache.storeMode : 프로퍼티 이름
* javax.persistence.CacheStoreMode : 설정 옵션
  * USE : 조회한 데이터 캐시에 저장. 조회한 데이터가 이미 캐시에 존재하면 갱신하지 않음. 트랜잭션 커밋시 등록 수정한 엔티티도 캐시에 저장. (기본값)
  * BYPASS : 캐시에 저장하지 않음.
  * REFRESH : USE 전략에 추가로 DB에서 조회한 엔티티를 최신 상태로 다시 캐시.

### 캐시 모드 예제

#### 1. 엔티티 매니저 범위

* EntityManager.setProperty()로 엔티티 매니저 단위로 설정.

```java
em.setProperty("javax.persistence.cache.retrieveMode", CacheRetrieveMode.BYPASS);
em.setProperty("javax.persistence.cache.storeMode", CacheStoreMode.BYPASS);
```

#### 2. find()나 refresh()

* 세밀하게 EntityManager.find(), EntityManager.refresh()로 설정.

```java
Map<String, Object> param = new HashMap<String, Object>();
param.put("javax.persistence.cache.retrieveMode", CacheRetrieveMode.BYPASS);
param.put("javax.persistence.cache.storeMode", CacheStoreMode.BYPASS);
em.find(TestEntity.class, id, param);
```

#### 3. JPQL

* Query.setHint()에 사용. (TypedQuery 포함)

```java
em.createQuery("select e from TestEntity e where e.id = :id", TestEntity.class)
        .setParameter("id", id)
        .setHint("javax.persistence.cache.retrieveMode", CacheRetrieveMode.BYPASS)
        .setHing("javax.persistence.cache.storeMode", CacheStoreMode.BYPASS)
        .getSingleResult();
```

## JPA 캐시 관리 API

* JPA는 캐시를 관리하기 위한 javax.persistence.Cache 인터페이스 제공.
* EntityManagerFactory에서 구함.

#### Cache 관리 객체 조회 예제

```java
Cache cache = emf.getCache();
boolean contains = cache.contains(TestEntity.class, testEntity.getId());
```

#### Cache 인터페이스

```java
public interface Cache {
    
    //해당 엔티티 캐시에 있는지 확인
    public boolean contains(Class cls, Object primaryKey);
    
    //해당 엔티티중 특정 식별자를 가진 엔티티를 캐시에서 제거
    public void evict(Class cls, Object primaryKey);
    
    //해당 엔티티 전체를 캐시에서 제거
    public void evict(Class cls);
    
    //모든 캐시 데이터 제거
    public void evictAll();
    
    //JPA Cache 구현체 조회
    public <T> T unwrap(Class<T> cls);
}
```





