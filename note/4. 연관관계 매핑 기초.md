엔티티는 다른 엔티티와 연관관계가 존재힌다. 객체는 참조(주소)를 사용해서 관계를 맺고, 테이블은 외래키를 사용해서 관계를 맺는다.
그래서 ORM에서 가장 어려운 부분이 객체 연관관계와 테이블 연관관계를 매핑하는 일이다.<br/>
따라서 객체의 참조와 테이블의 외래 키를 매핑하는 것이 목표.

* 연관관계 매핑의 핵심 키워드
    * 방향 (Direction) : 단방향(한쪽에서만 참조), 양방향(서로 참조). 방향은 객체관계에서만 존재하고 테이블은 항상 양방향.
    * 다중성 (Multiplicity) : 다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M)
    * 연관관계의 주인 : 객체로 양방향 관계를 했을 때 연관관계의 주인을 정해야 한다.

# 단방향 연관관계

연관관계의 기본은 다대일(N:1) 단방향 관계.

## 회원(Member)과 팀(Team)의 연관관계 예시
* 회원은 하나의 팀에만 소속
* 회원과 팀은 다대일 관계

### 객체 연관관계

* 회원 객체는 Member.team 필드로 팀과 연관관계를 맺는다.
* 회원 객체와 팀 객체는 단방향 관계이다. 그래서 팀은 회원을 알 수 없고, 따로 필드로 참조하지 않는다.
* 참조를 사용해서 연관관계를 탐색할 때 이것을 `객체 그래프 탐색`라고 한다.

### 테이블 연관관계

* 회원 테이블은 TEAM_ID 외래 키로 팀 테이블과 연관관계를 맺는다.
* 회원과 팀 테이블은 양방향 관계이다. 회원 테이블의 TEAM_ID 외래키를 통해서 회원과 팀 또는 팀과 회원을 조회할 수 있다.

### 객체 연관관계와 테이블 연관관계의 가장 큰 차이

참조를 통한 연관관계는 언제나 단방향이고 양방향을 하고싶으면 각 객체에서 필드로 참조해야한다.
따라서 객체 연관관계에서의 양방향은 사실상 `서로 다른 단방향 관계 2개`이다. 반면 테이블은 외래키 하나로 양방향 조인이 가능하다.

### 순수한 객체 연관관계

```java
  Member member1 = new Member("member1", "회원1");
        Member member2 = new Member("member2", "회원2");
        Team team1 = new Team("team1", "팀1");

        member1.setTeam(team1);
        member2.setTeam(team1);

        Team findTeam = member1.getTeam();
```

### 테이블 연관관계

```sql
SELECT T.*
FROM MEMBER M
         JOIN TEAM T ON M.TEAM_ID = T.ID
WHERE M.MEMBER_ID = 'member1'
```

### JPA를 사용한 객체 연관관계 매핑

회원과 팀의 연관관계를 JPA로 작성.

```java
@Entity
public class Member {

    @Id
    @Column(name = "member_id")
    private String id;

    // 연관관계 매핑
    @ManyToOne
    @JoinColumn(name = "team_id")
    private Team team;
 
  ...
}

@Entity
public class Team {

    @Id
    @Column(name = "team_id")
    private String id;

    private String name;
  
  ...
}
```

#### 위 코드에서의 매핑 애노테이션

**@ManyToOne** : 다대일 관계 매핑. 회원과 팀의 관계가 다대일 구조.

* 속성
    * optional : false로 설정 시 연관된 엔티티가 항상 존재해야 한다.
        * 기본값 : true
    * fetch : 글로벌 페치 전략.
        * 기본값 : @ManyToOne = FetchType.EAGER, @OneToMany = FetchType.LAZY
    * cascade : 영속성 전이.
    * targetEntity : 연관된 엔티티의 타입 정보 설정. 거의 사용하지 않는다. (보통 제네릭을 사용해서 타입 정보를 명시)

참고로 @OneToOne도 존재한다. 단방향 관계를 매핑할 때 어떤것을 사용할지는 반대편에 따라 달라진다. 반대편이 일대다이면 다대일을, 일대일이면 일대일관계를 매핑한다.

**@JoinColumn** : 외래 키를 매핑할 때 사용. name 속성에 매핑할 외래 키 이름을 지정. (생략 가능)

* 속성
    * name : 매핑할 외래 키 이름.
        * 기본값 : 필드명_참조하는 테이블의 기본 키 컬럼명.
    * referencedColumnName : 외래 키가 참조하는 대상 테이블의 컬럼명.
        * 기본값 : 참조하는 테이블의 기본키 컬럼명.
    * foreignKey(DDL) : 외래 키 제약조건을 직접 지정. 테이블 생성시에만 사용.
    * 나머지 옵션은 @Column과 같음.
    
참고로 @JoinColumn 생략하게되면 name 속성의 기본값으로 동작하게 된다. 위 소스 구조에서는 team_team_id (필드명_컬럼명) 으로 된다.

---

# 양방향 연관관계

양쪽에서 서로 접근할 수 있는 연관관계 매핑. 위의 단방향 관계 예시인 팀과 회원 연관관계에서 팀에서도 회원을 참조할 수 있는 구조가 된다.
팀 -> 회원 연관관계는 일대다 관계이기때문에 컬렉션으로 참조한다.

### 양방향 연관관계 매핑

```java
@Entity
public class Member {
    ...
    //회원 쪽은 수정할게 없음.
    @ManyToOne
    @JoinColumn(name = "team_id")
    private Team team;
    ...
}

@Entity
public class Team {
    ...
    //추가
    //mappedBy로 반대쪽 매핑 필드 이름값 추가.
    @OneToMany(mappedBy = "team")
    private List<Member> members = new ArrayList<>();
    ...
}k
```

양방향을 위해 Member는 더 수정할게 없지만 Team은 Member를 참조할 수 있도록 List 컬렉션으로 매핑했다.
    
            
        

    
