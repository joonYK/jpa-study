## 프록시

엔티티를 조회하면 연관된 엔티티를 실제 사용시에 데이터베이스에서 조회할 수 있는 방법을 제공하는데 이것을 `지연로딩`이라고 한다. 

예를 들어, Member와 Team이 다대일 매핑이고, Member를 조회해서 getTeam()로 Team 엔티티를 실제로 사용하는 시점에 DB에서 조회한다. 
그래서 Team까지 join으로 조회하지 않고 Member만 DB에서 조회한다.

그럼 Member 엔티티를 조회했을 때, 연관 엔티티인 Team는 실제 엔티티가 아니라 지연로딩을 위한 가짜 객체가 되는데
이 가짜 객체를 `프록시 객체`라고 한다.

※ 참고로 지연 로딩의 구현 방법은 JPA 구현체마다 다르며, 하이버네이트는 프록시를 사용하는것과 바이트코드를 수정하는 2가지 방법이 존재한다.

### 프록시의 특징

프록시 클래스는 실제 클래스를 상속받기 때문에 겉 모양은 실제 클래스와 같다. 그래서 사용시에는 프록시인지 아닌지 신경
쓰지않고 그냥 사용하면 된다. 프록시 객체는 실제 객체에 대한 참조를 보관해서 프록시 객체의 메서드를 호출하면 실제 객체의 메서드를
프록시 객체가 호출하게 된다.

### 프록시 객체의 초기화

프록시 객체는 실제 사용될 때 DB에서 조회하고 실제 객체를 생성하는데 이것을 프록시 객체의 초기화라고 한다.
초기화 후에는 프록시 객체를 통해서 실제 엔티티에 접근할 수 있다.

### 프록시 객체 반환

EntityManager.getRegerence() 메소드를 사용하면 프록시 객체를 반환받는다. 그래서 DB에서 조회하지 않고 실제 엔티티도 생성하지 않는다.

```java
Member member = em.getReference(Member.class, "member1"); //프록시 객체 반환
member.getName(); //실제 사용시에 DB에서 조회
```

하지만 영속성 컨텍스트에 찾는 엔티티가 있으면 프록시가 아닌 실제 엔티티를 반환한다.
그리고 당연하겠지만, 영속성 컨텍스트를 닫은 후에 초기화되지 않은 프록시 객체를 사용하게 되면 오류가 발생한다.

### 프록시와 식별자

프록시는 엔티티를 조회할 때 전달받는 식별자(PK)를 보관해둔다. 그래서 엔티티 접근 방식에 따라 
식별자 값을 조회하는 메서드(getter)를 호출해도 프록시를 초기화하지 않도록 할 수 있다. 

* @Access(AccessType.PROPERTY) : 프록시 초기화 하지 않음.
* @Access(AccessType.FIELD) : 프록시 초기화 (단순히 id만 조회하는 getter 메서드인지 아닌지 신경 쓰지 않음)

프록시는 식별자값을 저장하고 있기 때문에 연관관계를 설정할 때 DB 접근 횟수를 줄일 수 있다.
그리고 연관관계 설정시에는 엔티티 접근 방식이 필드여도 초기화하지 않는다.

```java
Member member = em.find(Member.class, "member");
Team team = em.getReference(Team.class, "team"); //SQL 실행 X
member.setTeam(team); // 식별자 값을 보관하고 있어서 연관관계 설정 가능
```

### 프록시 확인

JPA가 제공하는 PersistenceUnitUtil.isLoaded(Object entity) 메서드로 프록시 초기화 여부 확인이 가능하다.
```java
boolean isLoad = em.getEntityManagerFactory().getPersistenceUnitUtil().isLoaded(entity);
boolean isLoad = emf.getPersistenceUnitUtil().isLoaded(entity);
```

<br/>

## 즉시 로딩과 지연 로딩

연관된 엔티티의 조회 시점에 대한 두 가지 방법.

* 즉시 로딩 : 연관된 엔티티도 함께 조회. (@ManyToOne(fetch = FetchType.EAGER))
* 지연 로딩 : 실제 사용시에 조회. (@ManyToOne(fetch = FetchType.LAZY))

### 즉시 로딩

```java
@Entity
public class Member {

    @Id
    @Column(name = "MEMBER_ID")
    private String id;

    // ManyToOne에서 fetch의 기본값은 EAGER임.
    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "TEAM_ID")
    private Team team;
    ...
}

@Entity
public class Team {
    @Id
    @GeneratedValue
    @Column(name = "TEAM_ID")
    private Long id;
    ...
}
```
* 조회 쿼리 결과

```SQL
    select
        member0_.MEMBER_ID as member_i1_0_0_,
        member0_.name as name2_0_0_,
        member0_.TEAM_ID as team_id3_0_0_,
        team1_.TEAM_ID as team_id1_1_1_,
        team1_.name as name2_1_1_ 
    from
        Member member0_ 
    left outer join
        Team team1_ 
            on member0_.TEAM_ID=team1_.TEAM_ID 
    where
        member0_.MEMBER_ID=?
```

left outer join으로 회원과 팀을 함께 조회한다. 

#### 외부 조인(left outer join)과 내부 조인(inner join)

* 선택적 관계 : 외부 조인
* 필수 관계 : 내부 조인

위 쿼리에서 외부 조인을 사용한 이유는 회원 테이블에 TEAM_ID가 null 일수도 있기 때문이다. 내부 조인을 사용하면 팀에 소속되지 않은 회원은 조회되지 않는데, 내부 조인을
사용하려면 @JoinColumn 속성 중에 nullable = false로 not null 제약조건을 설정해줘야 한다. 그리고 당연히 내부 조인이 성능과 최적화에 더 좋다.

### 지연 로딩

```java
@Entity
public class Member {

    @Id
    @Column(name = "MEMBER_ID")
    private String id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "TEAM_ID")
    private Team team;
    ...
}
```
* 조회 쿼리 결과

```sql
    --회원 쿼리
    select
        member0_.MEMBER_ID as member_i1_0_0_,
        member0_.name as name2_0_0_,
        member0_.TEAM_ID as team_id3_0_0_ 
    from
        Member member0_ 
    where
        member0_.MEMBER_ID=?

    --팀 쿼리
    select
        team0_.TEAM_ID as team_id1_1_0_,
        team0_.name as name2_1_0_ 
    from
        Team team0_ 
    where
        team0_.TEAM_ID=?
```

조회 쿼리 출력을 보면 회원과 팀을 각각 조회했다. 그래서 Member 엔티티를 처음 조회했을 땐 Team은 프록시 객체이고,
실제 사용시점에 DB에서 조회한다. 하지만 영속성 컨텍스트에 해당 Member와 연관된 Team 엔티티가 조회한다면 프록시 객체가
아니라 실제 엔티티를 사용한다.

### 컬렉션 래퍼

하이버네이트는 엔티티에 컬렉션에 있으면 추적하고 관리할 목적으로 하이버네이트가 제공하는 내장 컬렉션으로 변경(컬렉션 래퍼)한다.
컬랙션 래퍼는 org.hibernate.collection.internal.PersistentBag 클래스 타입이고 지연 로딩시에 이 컬랙션 래퍼가 프록시 역할을 한다.

컬렉션은 객체 그래프로 조회해도 초기화되지 않고 컬렉션 내의 실제 데이터를 조회할 때, 예를 들어 member.getOrders().get(0) 과 같이
사용해야 DB에서 초기화 한다.

### JPA 기본 페치 전략

연관 엔티티가 하나면 즉시 로딩, 컬렉션이면 지연 로딩이 기본이다.
컬렉션이 기본 지연로딩인 이유는 연관된 엔티티가 수만건일 경우 조회시에 한번에 조인으로 같이 조회해버려서 성능에
문제가 발생할 수 있기 때문이다.

연관관계는 설정하는 효과적인 방법은 모두 지연 로딩을 하고, 실제 사용하는 상황을 보면서 필요한 곳에만 즉시 로딩을 
하는 것이다.

### 컬렉션에 즉시로딩 사용시 주의

#### 하나 이상의 컬렉션을 즉시로딩하지 않는다.

예를 들어 A 테이블이 B, C 테이블과 일대다 조인하면 SQL 실행 결과가 B 곱하기 C 만큼의 많은 데이터가 반환될 수 있어
성능이 저하될 수 있다.

#### 컬렉션 즉시 로딩은 항상 외부 조인을 사용한다.

다대일 관계로 조인시에 다쪽의 외래키에 not null 제약조건을 설정하면 내부 조인을 사용해도 된다. 하지만 반대의 경우인
일대다 관계로 조인시에는 다쪽에 연관된 데이터가 저장되지 않은 경우에 내부 조인을 하면 아예 조회되지 않을 수 있다. 따라서 JPA는 
일대다 관계를 즉시 로딩시에 항상 외부 조인을 사용한다.