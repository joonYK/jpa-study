## 프록시

엔티티를 조회하면 연관된 엔티티를 실제 사용시에 데이터베이스에서 조회할 수 있는 방법을 제공하는데 이것을 `지연로딩`이라고 한다. 

예를 들어, Member와 Team이 다대일 매핑이고, Member를 조회해서 getTeam()로 Team 엔티티를 실제로 사용하는 시점에 DB에서 조회한다. 
그래서 Team까지 join으로 조회하지 않고 Member만 DB에서 조회한다.

그럼 Member 엔티티를 조회했을 때, 연관 엔티티인 Team는 실제 엔티티가 아니라 지연로딩을 위한 가짜 객체가 되는데
이 가짜 객체를 `프록시 객체`라고 한다.

※ 참고로 지연 로딩의 구현 방법은 JPA 구현체마다 다르며, 하이버네이트는 프록시를 사용하는것과 바이트코드를 수정하는 2가지 방법이 존재한다.

### 프록시의 특징

프록시 클래스는 실제 클래스를 상속받기 때문에 겉 모양은 실제 클래스와 같다. 그래서 사용시에는 프록시인지 아닌지 신경
쓰지않고 그냥 사용하면 된다. 프록시 객체는 실제 객체에 대한 참조를 보관해서 프록시 객체의 메서드를 호출하면 실제 객체의 메서드를
프록시 객체가 호출하게 된다.

### 프록시 객체의 초기화

프록시 객체는 실제 사용될 때 DB에서 조회하고 실제 객체를 생성하는데 이것을 프록시 객체의 초기화라고 한다.
초기화 후에는 프록시 객체를 통해서 실제 엔티티에 접근할 수 있다.

### 프록시 객체 반환

EntityManager.getRegerence() 메소드를 사용하면 프록시 객체를 반환받는다. 그래서 DB에서 조회하지 않고 실제 엔티티도 생성하지 않는다.

```java
Member member = em.getReference(Member.class, "member1"); //프록시 객체 반환
member.getName(); //실제 사용시에 DB에서 조회
```

하지만 영속성 컨텍스트에 찾는 엔티티가 있으면 프록시가 아닌 실제 엔티티를 반환한다.
그리고 당연하겠지만, 영속성 컨텍스트를 닫은 후에 초기화되지 않은 프록시 객체를 사용하게 되면 오류가 발생한다.

### 프록시와 식별자

프록시는 엔티티를 조회할 때 전달받는 식별자(PK)를 보관해둔다. 그래서 엔티티 접근 방식에 따라 
식별자 값을 조회하는 메서드(getter)를 호출해도 프록시를 초기화하지 않도록 할 수 있다. 

* @Access(AccessType.PROPERTY) : 프록시 초기화 하지 않음.
* @Access(AccessType.FIELD) : 프록시 초기화 (단순히 id만 조회하는 getter 메서드인지 아닌지 신경 쓰지 않음)

프록시는 식별자값을 저장하고 있기 때문에 연관관계를 설정할 때 DB 접근 횟수를 줄일 수 있다.
그리고 연관관계 설정시에는 엔티티 접근 방식이 필드여도 초기화하지 않는다.

```java
Member member = em.find(Member.class, "member");
Team team = em.getReference(Team.class, "team"); //SQL 실행 X
member.setTeam(team); // 식별자 값을 보관하고 있어서 연관관계 설정 가능
```

### 프록시 확인

JPA가 제공하는 PersistenceUnitUtil.isLoaded(Object entity) 메서드로 프록시 초기화 여부 확인이 가능하다.
```java
boolean isLoad = em.getEntityManagerFactory().getPersistenceUnitUtil().isLoaded(entity);
boolean isLoad = emf.getPersistenceUnitUtil().isLoaded(entity);
```









