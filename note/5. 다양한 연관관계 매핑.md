# 다대일

테이블의 연관관계에서 항상 다쪽이 외래키를 저장하고 관리한다. 
그래서 객체 연관관계에서도 다쪽이 항상 연관관계의 주인(외래키를 관리)이 된다.

## 다대일 단방향

연관관계의 주인인 다쪽에서만 참조 관계를 맺어준다. @ManyToOne 과 @JoinColumn으로 연결.

```java
@Entity
public class Member {
    ...
    @ManyToOne
    @JoinColumn(name = "TEAM_ID")
    private Team team;
    ...
}

@Entity
public class Team {
    @Id
    @Column(name = "TEAM_ID")
    private Long id;
    ...
}
```

## 다대일 양방향

양방향 연관관계는 양쪽에서 서로 참조하는 2개의 단방향 연관관계를 맺어주는 관계이다.
연관관계의 주인은 단방향처럼 참조 관계를 맺어주면 되고, 주인이 아닌 반대쪽은 @OneToMany와 mappedBy속성으로
참조 관계를 매핑해준다. mappedBy 속성은 반대편에서 참조중인 필드 이름으로 적어준다.

```java
@Entity
public class Member {
    ...
    @ManyToOne
    @JoinColumn(name = "TEAM_ID")
    private Team team;
    
    //연관관계 편의 메서드
    public void setTeam(Team team) {
        this.team = team;
        if(!team.getMembers().contains(this))
            team.getMembers().add(this);
    }
    ...
}

@Entity
public class Team {
    ...
    @OneToMany(mappedBy = "team")
    private List<Member> members = new ArrayList<>();
    
    //연관관계 편의 메서드
    public void addMember(Member member) {
        this.members.add(member);
        if (member.getTeam() != this)
            member.setTeam(this);
    }
    ...
}
```

<br/>

# 일대다

일대다 관계는 엔티티를 하나이상 참조할 수 있어서 자바 컬렉션을 사용한다.

## 일대다 단방향

일대다 단방향은 약간 특이한데, 연관관계의 주인인 다 쪽에서 참조하는 것이 아니라 주인이 아닌 쪽에서만 참조하는
구조이다. 그래서 주인이 아닌쪽에서 반대편 테이블의 외래키를 관리하는 특이한 모습이 된다.

```java
@Entity
public class Member {
    ...
}

@Entity
public class Team {
    @Id
    @Column(name = "TEAM_ID")
    private Long id;

    @OneToMany
    @JoinColumn(name = "TEAM_ID") //MEMBER 테이블의 TEAM_ID (FK)
    private List<Member> members = new ArrayList<>();
    ...
}
```

일대다 단방향 관계를 매핑할 때는 @JoinColumn을 명시해야 한다. 그렇지 않으면 JPA는 연결 테이블을 중간에 둬서
관계를 맺는 조인 테이블 전략을 기본으로 사용해서 매핑한다.

### 일대다 단방향 매핑의 단점

단점은 매핑한 객체가 관리하는 외래 키가 다른 테이블에 있다는 점이다. 본인 테이블에 외래 키가 있으면 INSERT SQL로 직접
한 번에 저장하면 되지만, 반대편에 있기 때문에 UPDATE SQL을 추가로 실행해야 한다. 그래서 일대다 단반향 보다는
다대일 양방향 매핑을 사용하는 것이 성능상 더 좋다.

## 일대다 양방향

사실 일대다 양방향은 존재하지 않으며, 대신 다대일 양방향 매핑을 사용해야 한다. (일대다 양방향, 다대일 양방향은
사실 똑같은 말이다. 그리고 항상 다 쪽이 연관관계의 주인이다.)<br/>
애초에 관계형 데이터베이스 특성상 다 쪽의 테이블이 외래 키를 관리하기 때문에 @OneToMany는 연관관계의 주인이 될 수 없다.
그래서 @ManyToOne 에서도 연관관계 주인의 반대편이라는 mappedBy 속성이 존재하지 않는다.<br/>
하지만 완전히 불가능한 것은 아니며, 일대다 단방향 매핑 반대편에 같은 외래 키를 사용하는 다대일 단방향 매핑을 읽기 전용으로 추가하면 된다.

```java
@Entity
public class Member {
    ...
    @ManyToOne
    @JoinColumn(name = "TEAM_ID", insertable = false, updatable = false)
    private Team team;
    ...
}

@Entity
public class Team {
    @Id
    @Column(name = "TEAM_ID")
    private Long id;

    @OneToMany
    @JoinColumn(name = "TEAM_ID")
    private List<Member> members = new ArrayList<>();
    ...
}
```

위 처럼 같은 외래 키 컬럼을 매핑해서 같은 키를 관리하도록 했다. 대신 @ManyToOne 쪽은 읽기만 가능하게 했다.
이 방법은 일대다 양방향 매핑이라기보다는 다 쪽에서 읽기 전용으로만 추가해서 마치 양방향으로 보이도록 하는 방법이다.
따라서 일대다 단방향 매핑이 가지는 단점을 그대로 가지기 때문에 웬만하면 다대일 양방향 매핑을 사용해야 한다.

<br/>

# 일대일

양쪽이 서로 하나의 관계만 가지며 예를 들어 회원(주 테이블)과 사물함(대상 테이블)의 관계를 일대일 관계의 예로 들 수 있다.
일대일 관계는 일대다, 다대일과 다르게 둘 중 어느곳이나 외래 키를 가질 수 있다. 그래서 일대일 관계는
주 테이블이나 대상 테이블중에 누가 외래 키를 가질지 선택해야 한다.

* 주 테이블 외래 키

    주 테이블에 외래 키를 두고 대상 테이블을 참조. 외래 키를 객체 참조와 비슷하게 사용할 수 있다.
    이 방법은 주 테이블만 확인해도 대상 테이블과 연관관계가 있는지 확인할 수 있어서 객체지향 개발자들이 선호한다.


* 대상 테이블에 외래 키

    전통적인 데이터베이스 개발자들이 선호하는 방법. 이 방법의 장점은 테이블 관계가 일대일에서 일대다로 변경할 
    때 테이블 구조를 그대로 유지할 수 있다.

## 주 테이블에 외래 키

### 단방향

다대일 단방향 관계과 비슷하다.

```java
@Entity
public class Member {
    ...
    @OneToOne
    @JoinColumn(name = "LOCKER_ID")
    private Locker locker;
    ...
}

@Entity
public class Locker {
    ...
}
```

### 양방향

양방향이므로 연관관계의 주인을 정해야 한다. 주인이 아닌쪽은 mappedBy 속성으로 매핑한다.

```java
@Entity
public class Member {
    ...
    @OneToOne
    @JoinColumn(name = "LOCKER_ID")
    private Locker locker;
    ...
}

@Entity
public class Locker {
    ...
    @OneToOne(mappedBy = "locker")
    private Member member;
    ...
}
```

## 대상 테이블에 외래 키

### 단방향

일대일 관계에서 대상 테이블에 외래 키가 있는 단방향 관계는 JPA가 지원하지 않는다. 이런 모양으로 매핑할 수 있는
방법도 없어서 단방향 관계를 Locker에서 Member 방향으로 수정하거나, 양방향 관계로 만들어서 Locker를 연관관계의
주인으로 설정해야 한다.

### 양방향

대상 테이블에 외래 키를 두고싶을때는 양방향 매핑을 한다. Locker를 연관관계의 주인으로 만들어서
LOCKER 테이블이 외래 키를 관리하도록 한다. 

```java
@Entity
public class Member {
    ...
    @OneToOne(mappedBy = "member")
    private Locker locker;
    ...
}

@Entity
public class Locker {
    ...
    @OneToOne
    @JoinColumn(name = "MEMBER_ID")
    private Member member;
    ...
}
```

* 주의사항

프록시를 사용할 때 외래 키를 직접 관리하지 않는 일대일 관계는 지연 로딩을 설정해도 즉시 로딩된다.
위의 예제에서 Locker.member는 지연 로딩할 수 있지만, Member.locker는 즉시 로딩만 된다. 프록시의 한계때문에
발생하며 bytecode instrumentation 을 사용해서 해결할 수 있다. (자세한 내용 추후 정리)

